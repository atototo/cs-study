

# 1. 자료구조와 알고리즘

import DataStructureClassificationImg from '@site/static/img/data_structure_classification.png';
import ArrayVsLinkedListImg from '@site/static/img/array_vs_linkedlist_memory_structure.png';
import ArrayInsertionDeletionImg from '@site/static/img/array_insertion_deletion_process.png';
import LinkedListTypesImg from '@site/static/img/linked_list_types_diagram.png';
import StackOperationImg from '@site/static/img/stack_operation_diagram.png';
import QueueOperationImg from '@site/static/img/queue_operation_diagram.png';
import QueueTypesImg from '@site/static/img/queue_types_comparison.png';
 
## 자료구조의 개요
- 자료를 효율적으로 표현하고 저장하고 처리 할 수 있도록 정리 하는 것을 말한다. 
- 쉽게 비유하자면 **물건을 용도에 맞게 정리 수납하는 방법** 이다.
    - 책장에 책을 꽂을 것인가? (순차적 접근 유리)
    - 박스에 차곡 차곡 쌓을 것인가? (가장 나중에 넣은 걸 먼저 꺼내기 유리 - 스택)
    - 줄을 서서 기다리게 할 것인가? (먼저 온 사람이 먼저 처리됨 - 큐)
- ***한정된 자원(시간과 메모리) 안에서 프로그램의 성능(효율성)을 극대화 하기 위해*** 자료구조가 중요함 
- 자료구조 선택 기준 
    - 시간복잡도 (Time complexity) : 실행 속도가 얼마나 빠른가? (검색, 삽입, 삭제가 얼마나 걸리는가) 
    - 공간복잡도 (Space complexity) : 메모리 사용량이 얼마나 효율적인가? 


### 자료구조의 분류

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={DataStructureClassificationImg} 
    alt="자료구조 분류도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

| 분류 | 특징 | 종류 |
|---|---|---|
| **선형 구조**<br/>(Linear) | - 데이터가 **한 줄로** 연결된 구조<br/>- 데이터 간의 관계가 **1:1**<br/>- 구현이 쉽고 직관적임 | **리스트 (List)**: 선형 리스트(배열), 연결 리스트<br/>**스택 (Stack)**: LIFO (후입선출)<br/>**큐 (Queue)**: FIFO (선입선출)<br/>**데크 (Deque)**: 양쪽 삽입/삭제 가능 |
| **비선형 구조**<br/>(Non-Linear) | - 데이터가 **망 형태**나 **계층적**으로 연결된 구조<br/>- 데이터 간의 관계가 **1:N** 또는 **N:M**<br/>- 복잡한 데이터 표현에 적합 | **트리 (Tree)**: 부모-자식 관계 (계층형, 1:N)<br/>**그래프 (Graph)**: 노드 간의 복잡한 연결 (네트워크형, N:M) |

## 선형구조

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={ArrayVsLinkedListImg} 
    alt="순차 리스트(배열) vs 연결 리스트 구조 비교" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 1. 순차 리스트 / 선형 리스트 
- 리스트에 나열한 데이터들이 일정한 순서를 가지고 있는 구조
- 각 요소가 인덱스를 통해 접근 가능하다.
- 요소들이 메모리사에 연속적으래 배치되어 있다.
- **시간 복잡도**
    - **접근 (Access)**: **O(1)** - 인덱스(주소)를 알면 한 번에 찾아감 (매우 빠름, "아파트 호수로 찾아가기")
    - **검색 (Search)**: **O(n)** - 특정 값을 찾으려면 처음부터 순서대로 확인해야 함
    - **삽입/삭제 (Insert/Delete)**: **O(n)** - 중간에 끼워넣으려면 뒤의 데이터를 다 밀어야 함 (느림, "영화관 중간 자리 끼어들기")

    <div style={{ textAlign: 'center', margin: '2rem 0' }}>
      <img 
        src={ArrayInsertionDeletionImg} 
        alt="배열의 삽입과 삭제 동작 과정" 
        style={{ 
          maxWidth: '600px', 
          width: '100%', 
          borderRadius: '20px', 
          boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
        }} 
      />
    </div>

    > **💡 왜 느린가요? (Data Shifting)**
    > - **삽입 시**: 중간에 자리를 만들기 위해 뒤에 있는 모든 데이터를 **한 칸씩 뒤로 밀어야(Shift Right)** 합니다.
    > - **삭제 시**: 빈 자리를 채우기 위해 뒤에 있는 모든 데이터를 **한 칸씩 앞으로 당겨야(Shift Left)** 합니다.
    > - 데이터가 100만 개라면? 1개 넣으려고 100만 번 이동해야 할 수도 있습니다! (최악의 경우)
- **장점**: 구현이 간단하고, **인덱스를 통한 접근(Access) 속도**가 매우 빠르다.
- **단점**: 데이터의 삽입/삭제 시 많은 이동이 필요하다. 메모리 낭비가 발생할 수 있다.
- **구현체**: C언어 배열, **Java ArrayList**

> **[실무/면접] Java ArrayList: `set()` vs `add()` 차이점**
>
> | 구분 | `set(index, value)` | `add(index, value)` |
> |:---:|---|---|
> | **동작** | **덮어쓰기 (Update)** | **끼워넣기 (Insert)** |
> | **기능** | 해당 인덱스의 값을 **교체**함 | 해당 인덱스에 값을 넣고, 뒤의 요소들을 **밀어냄** |
> | **인덱스 변화** | **없음** (기존 위치 그대로) | **발생** (삽입된 위치 뒤는 모두 +1씩 밀림) |
> | **시간 복잡도** | **O(1)** (매우 빠름) | **O(N)** (밀어내는 비용 발생) |
>
> - **결론**: 단순히 값을 바꿀 땐 `set`을 쓰고, 중간에 새 데이터를 추가해야 할 때만 `add`를 써야 합니다. 

#### [핵심] 리스트가 갖춰야 할 기본 기능 (ADT)
- 자료구조에서 **ADT (Abstract Data Type, 추상 자료형)** 는 "내부 구현(배열, 연결리스트)은 모르겠지만, 적어도 이 기능들은 있어야 해!"라는 약속입니다.

1.  **쓰기 (Insert/Add)**: 원하는 위치에 데이터를 끼워 넣는다. (밀어내기 발생)
2.  **지우기 (Delete/Remove)**: 원하는 위치의 데이터를 삭제한다. (당겨오기 발생)
3.  **읽기 (Get/Access)**: 특정 위치(인덱스)의 값을 확인한다.
4.  **찾기 (Search)**: 특정 값이 몇 번째에 있는지 찾는다. (순차 탐색)
5.  **정보 확인**: 전체 크기(`size`)나 비어있는지(`isEmpty`) 확인한다.

#### [실습] Java ArrayList 동작 확인하기
아래 코드는 `add`, `set`, `remove`, `indexOf`의 동작 차이를 보여줍니다.

```java
import java.util.ArrayList;
import java.util.List;

public class ArrayListTest {
    public static void main(String[] args) {
        // 1. 초기 데이터 추가
        List<String> list = new ArrayList<>();
        list.add("A"); list.add("B"); list.add("C");
        
        // 2. add(index, element): 끼워넣기 (Shifting 발생 O)
        // -> 인덱스 1에 'NEW' 삽입. 기존 'B'는 뒤로 밀려남
        list.add(1, "NEW"); 
        
        // 3. set(index, element): 덮어쓰기 (Shifting 발생 X)
        // -> 인덱스 2('B')를 'MODIFIED'로 교체. 위치 변화 없음
        list.set(2, "MODIFIED");
        
        // 4. remove(index): 삭제하기 (Shifting 발생 O)
        // -> 인덱스 1('NEW') 삭제. 뒤에 있던 애들이 앞으로 당겨짐
        list.remove(1);

        // 5. indexOf(value): 값으로 위치 찾기 (순차 탐색)
        // -> "0번방 너니? 1번방 너니?" 하며 찾음. (Map.get() 처럼 즉시 찾는게 아님!)
        int index = list.indexOf("C");
    }
}
```

---

### 2. 연결 리스트 (Linked List)
- 각 요소가 다음 요소에 대한 참조를 가지고 있어 연속적으로 데이터를 저장하는 방식
- 순차 리스트와 달리 메모리상에 연속적으로 배치 되지 않는다.
- 자료들을 임의의 기억공간에 기억시키되, 데이터 항목(필드)과 다음 데이터 위치를 가리키는 포인터(링크)를 사용하여 서로 연결시킨 구조
- **시간 복잡도**
    - **접근/검색 (Access/Search)**: **O(n)** - 인덱스가 없으므로 무조건 처음부터 순서대로 찾아가야 함 (느림, "보물찾기 쪽지 따라가기")
    - **삽입/삭제 (Insert/Delete)**: **O(1)** - 연결 고리만 끊고 다시 연결하면 됨 (매우 빠름, 단, 해당 위치까지 가는 시간 제외)
- **장점**: 삽입/삭제가 용이하고, 연속된 메모리 공간이 필요 없다.
- **단점**: 포인터 저장을 위한 추가 공간이 필요하고, 검색 속도가 느리다.
- **구현체**: **Java LinkedList**

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={LinkedListTypesImg} 
    alt="단순, 이중, 원형 연결 리스트 비교" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 1) 단순 연결 리스트 (Singly Linked List)
- **구조**: `[Data | Next]`
- 노드가 다음 노드를 가리키는 포인터(Next) 하나만 가짐.
- **단점**: 뒤로 돌아갈 수 없다. (단방향)

#### 2) 이중 연결 리스트 (Doubly Linked List) -> ★★ Java LinkedList
- **구조**: `[Prev | Data | Next]`
- 노드가 앞(Prev)과 뒤(Next)를 모두 가리킴.
- **장점**: 양방향 탐색 가능. 삭제 시 이전 노드를 바로 알 수 있어 효율적.
- **단점**: 포인터가 2개라 메모리를 더 많이 먹음.

#### 3) 원형 연결 리스트 (Circular Linked List)
- 마지막 노드의 Next가 처음 노드(Head)를 가리킴.
- 끝이 없이 빙글빙글 도는 구조 (스트림 버퍼 등에 사용)

> **🕵️‍♀️ [Deep Dive] Java `LinkedList` 뜯어보기**
> 
> Java의 `java.util.LinkedList`는 실제로 **이중 연결 리스트(Doubly Linked List)** 로 구현되어 있습니다.
> 실제 Java 내부 코드를 보면 `Node` 클래스가 다음과 같이 생겼습니다.
>
> ```java
> // 실제 Java LinkedList 내부의 Node 클래스 (단순화)
> private static class Node<E> {
>     E item;      // 데이터
>     Node<E> next; // 다음 노드 (Next)
>     Node<E> prev; // 이전 노드 (Prev) -> 이래서 양방향!
>     
>     Node(Node<E> prev, E element, Node<E> next) {
>         this.item = element;
>         this.next = next;
>         this.prev = prev;
>     }
> }
> ```
> - **결론**: 그래서 Java의 LinkedList는 앞뒤로 자유롭게 이동이 가능하고, `Deque`(양쪽 끝 입출력) 인터페이스도 구현하고 있는 것입니다.

---

#### 💡 [면접 대비] 순차 리스트(ArrayList) vs 연결 리스트(LinkedList) 언제 쓸까?

| 구분 | 순차 리스트 (ArrayList) | 연결 리스트 (LinkedList) |
|:---:|---|---|
| **구조** | 연속된 메모리 공간 (Array) | 포인터로 연결된 비연속 공간 |
| **장점** | **접근(Access)이 빠름 (O(1))** | **삽입/삭제가 빠름 (O(1))** |
| **단점** | 중간 삽입/삭제 시 데이터 이동 비용 발생 | 특정 원소 접근 시 순차 탐색해야 해서 느림 |
| **유리한 경우** | 1. **읽기(접근) 작업이 많을 때**<br/>2. 데이터 개수가 크게 변하지 않을 때 | 1. **데이터 수정(삽입/삭제)이 빈번할 때**<br/>2. 데이터 개수를 예측하기 어려울 때 |

### 3. 스택 (Stack)
- **개념**: 한 쪽 끝(Top)에서만 자료를 넣거나 뺄 수 있는 제한적 자료구조 (ADT).
    - 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조 
- **특징**: **후입선출 (LIFO, Last-In First-Out)** - "나중에 들어온 놈이 먼저 나간다" (프링글스 통, 접시 쌓기)
- **용도**: 함수 호출 스택(재귀), 웹 브라우저 뒤로 가기, 괄호 검사 `{}`, `()` , 문자열 역순 변환, 일시적인 데이터 저장 

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={StackOperationImg} 
    alt="스택의 Push와 Pop 동작 원리" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 스택의 주요 연산 (ADT)
1. **Push (삽입)**: Top 위치에(스택의 맨 위) 데이터를 추가한다.
2. **Pop (삭제)**: Top 위치의(스택의 맨 위) 데이터를 꺼내고 리스트에서 제거한다.
3. **Peek (조회)**: Top 위치의(스택의 맨 위) 데이터를 제거하지 않고 값만 확인한다.
4. **IsEmpty**: 스택이 비었는지 확인한다. (Pop 하기 전에 꼭 체크!)
- **스택을 이용한 연산** : 재귀호출, 후위표현(Post-fix expression)의 연산, 깊이우선탐색(DFS)

#### 스택의 구현 방법 2가지
| 구분 | 배열 스택 (Array Stack) | 연결 리스트 스택 (Linked Stack) |
|---|---|---|
| **구조** | 1차원 배열로 구현 | 단순 연결 리스트로 구현 |
| **장점** | 구현이 매우 쉽다. | 크기 제한이 없다. (메모리 찰 때까지) |
| **단점** | 크기가 고정됨 -> 꽉 차면 **Overflow** 발생! | 포인터 때문에 메모리를 조금 더 씀. |

> **🚫 [실무/면접] Java에서 `Stack` 클래스 쓰지 마세요?**
>
> 1. **이유**: `Stack`은 `Vector`를 상속받았는데, 모든 메서드에 `synchronized`가 걸려 있어 느리고 무겁습니다. (단일 스레드에서도 불필요한 lock 발생)
> 2. **공식 권장**: [Oracle Java 공식 문서](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Stack.html)에서도 대놓고 **`Deque`**를 쓰라고 권장합니다.
>    > *"A more complete and consistent set of LIFO stack operations is provided by the `Deque` interface... For example: `Deque<Integer> stack = new ArrayDeque<Integer>();`"*
> 3. **결론**: 코딩 테스트나 실무에서는 **`ArrayDeque`**를 사용하세요!
>    ```java
>    Deque<Integer> stack = new ArrayDeque<>();
>    stack.push(1);
>    stack.pop();
>    ```

### 4. 큐 (Queue)
- **개념**: 한쪽 끝(Rear)에서는 넣고, 반대쪽 끝(Front)에서는 빼는 선형 구조 (ADT).
- **특징**: **선입선출 (FIFO, First-In First-Out)** - "먼저 들어온 놈이 먼저 나간다" (버스 줄서기, 터널), 먼저 삽입된 데이터가 먼저 제거된다.
- **용도**: 프로세스 스케줄링(OS), 프린터 대기열, 데이터 스트림 처리, BFS(너비 우선 탐색), 메시지 큐

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={QueueOperationImg} 
    alt="큐의 Enqueue와 Dequeue 동작 원리" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 큐의 주요 연산 (ADT)
1. **Enqueue (삽입)**: Rear(뒤 : 큐의 뒤에) 위치에 새로운 데이터를 추가한다.
2. **Dequeue (삭제)**: Front(앞 : 큐의 앞에 ) 위치의 데이터를 꺼내고 제거한다.
3. **Peek / Front (조회)**: 맨 앞의 데이터를 제거하지 않고 확인한다.
4. **IsEmpty**: 큐가 비었는지 확인한다. (Dequeue 하기 전에 꼭 체크!)
5. **Size (크기)**: 큐의 크기를 확인한다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={QueueTypesImg} 
    alt="선형 큐, 원형 큐, 우선순위 큐 비교" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 큐의 종류와 문제점 해결
1. **선형 큐 (Linear Queue)**
   - 막대기 모양으로 구현.
   - **문제점**: 삭제(Dequeue)를 하면 앞 공간이 비게 되는데, 꽉 찼다고(Overflow) 인식하는 문제가 발생 (공간 낭비).
2. **원형 큐 (Circular Queue)** -> **시험 단골!**
   - 선형 큐의 앞쪽 빈 공간 문제를 해결하기 위해 **꼬리를 머리에 연결**한 구조.
   - `% (나머지 연산)`을 사용하여 인덱스를 순환시킴.
3. **우선순위 큐 (Priority Queue)**
   - FIFO가 아니라 **"우선순위가 높은 놈"**이 먼저 나간다. (응급실 등)

> **💡 [실무] Java에서 큐 사용하기**
> 
> Java에서는 `Queue` 인터페이스를 사용하며, 구현체로는 주로 `LinkedList`나 `ArrayDeque`를 씁니다.
> ```java
> Queue<String> queue = new LinkedList<>(); // 또는 new ArrayDeque<>();
> queue.add("First");
> queue.poll(); // 꺼내기
> ```
>
> **💡 [코테 꿀팁] `PriorityQueue` (우선순위 큐) 활용**
> 코딩 테스트(최단 경로, 힙 정렬 등)에서 필수입니다.
> 
> ```java
> import java.util.PriorityQueue;
> import java.util.Collections;
> 
> // 1. 기본형: 낮은 숫자가 우선 (오름차순) -> Min Heap
> PriorityQueue<Integer> pq = new PriorityQueue<>();
> pq.add(5); pq.add(1); pq.add(3);
> System.out.println(pq.poll()); // 결과: 1 (가장 작은 수)
> 
> // 2. 반대형: 높은 숫자가 우선 (내림차순) -> Max Heap
> PriorityQueue<Integer> reversePq = new PriorityQueue<>(Collections.reverseOrder());
> reversePq.add(5); reversePq.add(1); reversePq.add(3);
> System.out.println(reversePq.poll()); // 결과: 5 (가장 큰 수)
> ```

### 4. 큐 (Queue)
- **개념**: 한쪽 끝(Enqueue)에서 자료를 추가하고, 다른 쪽 끝(Dequeue)에서 자료를 제거하는 제한적 자료구조 (ADT).

