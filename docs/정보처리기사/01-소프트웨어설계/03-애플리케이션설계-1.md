---
id: 애플리케이션설계-1
---
import ModularityImg from '@site/static/img/modularity_concept.png';

# 애플리케이션 설계 1        
### 공통 모듈 설계

## 1. 모듈화 (Modularity)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={ModularityImg} 
    alt="모듈화 개념" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 1) 모듈화 개념
- 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화함으로써 시스템의 수정 및 재사용, 유지 관리를 용이하게 하는 기법을 의미한다.

### 2) 모듈화 필요성
- 모듈의 크기가 너무 작아서 모듈 개수가 많아지면 모듈 간의 통합 비용이 많이 들고, 모듈의 크기가 너무 크면 모듈하나를 개발하는데 드는 비용이 커진다.

#### 시스템을 이루는 요소들 
### 컴포넌트 
- 분명한 역할을 가지고 있는, 하드웨어 또는 소프트웨어 조각이다.
- 독존할 수 있으며 같은 기능을 가진 다른 컴포넌트로 대체 가능해야 한다.
#### 모듈
- 하나의 기능을 수행하는 부품 집합이다.
- 모듈은 컴포넌트로 구성된다.
#### 프레임워크
- 목적에 필요한 것들을 한꺼번에 가져다  쓰도록 만들어 놓은 '구조화된 틀'을 말한다.

### 공통 모듈에 대한 명세 작성의 원칙
| 원칙 |개념 |
|--|----------|
| 정확성(Correctness) | 해당 기능이 실제 시스템 구현 시 필요한지 여부를 알 수 있도록 정확하게 작성한다.|
| 명확성(Clarity) | 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성한다.|
| 완전성(Completeness) | 시스템이 구현될 때 필요하고 요구되는 모든 것을 기술한다. |
| 일관성(Consistency) | 공통 기능들 간에 상호 충돌이 없도록 작성한다. |
| 추적성(Traceability) | 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 작성한다 |

### 재공학 vs 재사용 
 - 재공학 (Reengineering) : 기존 시스템을 개선하거나 현대화 하는 것
 - 재사용 (Reuse) : 기존 소프트웨어를 새로운 개발에 활용하여 효율성을 높이는 것 
    - 함수와 객체 재사용, 컴포넌트 재사용, 애플리케이션 재사용 등이 가능 
    - 외부 모듈과의 연관성(결합도)는 적어야 하며, 자체적인 완성도(응집도)는 높아야 한다.
    - 누구나 사용 가능하도록 사용법이 공개되어야 한다.

import CohesionImg from '@site/static/img/cohesion_types.png';
import CouplingImg from '@site/static/img/coupling_types.png';
import LayeredPatternImg from '@site/static/img/layered_pattern.png';
import ClientServerImg from '@site/static/img/client_server_pattern.png';
import PipeFilterImg from '@site/static/img/pipe_filter_pattern.png';
import BrokerPatternImg from '@site/static/img/broker_pattern.png';
import MvcPatternImg from '@site/static/img/mvc_pattern.png';
import MasterSlaveImg from '@site/static/img/master_slave_pattern.png';

## 2. 응집도 (높을수록 좋음!!)
- 응집도는 모듈 내부에서 구성 요소간에 밀접한 관계를 맺고 있는 정도로 평가되며, 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소들로 구성되어 있다.

### 응집도의 유형
| 유형 | 개념 |
|--|----------|
| 기능적 응집도  (Functional Cohesion)| 모듈 내부의 모든 기능이 단일한 목적을 위해 수행 되는 경우, 딱 하나의 기능만 수행 |
| 순차적 응집도 (Sequential Cohesion) | 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우, A의 출력이 B의 입력이 되는 구조 |
| 통신(교환)적 응집도 (Communicational Cohesion) | 처리 순서에 상관없이 동일한 자료를 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우 |
| 절차적 응집도 (Procedural Cohesion) | 입출력 순서는 관련 없는 기능요소인데 배열된 순서로 수행하는 경우, 실행순서만 정해져 있고, 기능은 제각각 (예시 : 접근권한체크 후 로그기록 ) |
| 시간적 응집도 (Temporal Cohesion) | 특정 시간에 처리되어야 하는 활동 (예 : 시스템의 시작, 초기화, 에외 사항 발생 시) |
| 논리적 응집도 (Logical Cohesion) | 유사한 성격을 갖거나 특정 형태로 분류되는 처리요소들 (예 : 마우스 및 키보드 입력 처리 루틴 그룹화)|
| 우연적 응집도 (Coincidental Cohesion) | 모듈 내부의 각 구성 요소들이 연관이 없을 경우 |

### 응집도와 품질
- 다양한 기준으로 모듈을 구성할 수 있으나 품질 측면에서 기능적 응집도가 가장 품질이 높고, 우연적 응집도가 가장 낮다. 

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={CohesionImg} 
    alt="응집도 유형 및 순서" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div> 

## 3. 결합도 (낮을수록 좋음!!)
- 모듈과 모듈 간에 어느 정도 관련성이 있는지를 나타내며, 관련이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 적어지게 된다.

### 결합도의 유형
|유형 | 개념 |
|--|----------|
| 자료 결합도 (Data Coupling) | 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호 작용이 일어나는 경우 |
| 스탬프 결홥도 (Stamp Coupling) | 모듈 간의 인터페이스로 배열이나 오프젝트(DTO), 스트럭처 등이 전달되는 경우, 안 쓰는 데이터까지 전달 됨 |
| 제어 결합도 (Control Coupling) | 단순 처리할 대상인 값만 절달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되어 다른 모듈의 흐름을 제어 (상위 모듈이 하위에 무엇을 할지 flag를 던져 제어) |
| 외부 결합도 (External Coupling) | 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 디바이스 인터페이스를 공유할 때 발생 |
| 공통 결합도 (Common Coupling) | 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우 |
| 내용 결합도 (Content Coupling) | 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우 |

### 결합도와 품질
- 다양한 결합으로 모듈을 구성할 수 있으나 품질 측면에서 자료 결합이 가장 품질이 높고, 내용 결합이 가장 낮다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={CouplingImg} 
    alt="결합도 유형 및 순서" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 팬인(Fan-in)과 팬아웃(Fan-out)
- 팬인 : 특정 함수나 모듈에 들어오는 호출의 개수
- 팬아웃 : 특정 함수나 모듈이 호출하는 외부 함수나 모듈의 개수 
- 팬인은 높게 하고 팬아웃은 낮게 해야 복잡도를 줄일 수 있다.

## 소프트웨어 아키텍처
- 소프트웨어 개발을 쉽게 할 수 있는 기본 틀을 만드는 것
- 아키텍처 패턴의 정의 : 소프트웨어 아키텍처에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다.

### 아키텍처 4+1 뷰
- 고객의 요구사항을 정리해 놓은 유스케이스 뷰(Use Case View)를 중심으로 4개의 뷰가 유기적으로 겹쳐진 구조

| 뷰(View) | 개념 및 특징 | 관련 이해관계자 (관점) |
|---|---|---|
| 유스케이스 뷰 (Use Case View) | - 시스템의 외부 행위와 사용자의 요구사항을 나타냄<br/>- 다른 뷰를 검증하는 기준이 됨 (+1) | 사용자, 설계자, 개발자, 테스터 |
| 논리 뷰 (Logical View) | - 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명<br/>- 클래스, 객체, 관계 등으로 표현 | 설계자, 최종 사용자 |
| 프로세스 뷰 (Process View) | - 시스템의 비기능적인 속성(성능, 효율성, 동시성 등)을 표현<br/>- 스레드, 프로세스 등의 동시성 및 병렬 처리를 다룸 | 시스템 통합자 (System Integrator) |
| 구현 뷰 (Implementation View) | - 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여줌<br/>- 컴포넌트 구조와 의존성을 나타냄 | 프로그래머 |
| 배포 뷰 (Deployment View) | - 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는지 매핑<br/>- 시스템의 물리적 배치 (서버, 네트워크 등) 설명 | 시스템 엔지니어 |

### 일반적인 소프트웨어 아키텍처 패턴의 종류 
#### 계층화 패턴 (Layered pattern)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={LayeredPatternImg} 
    alt="계층화 패턴 구조" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

- 소프트웨어르 계층 단위로 나눈 구조화 된 패턴 이다.
- 각 게층이 특정 역하로가 책임을 가지며, 계층 간의 의존성을 최소화하여 시스템의 유지보수성과 확장성을 향상 시킬 수 있다.
- 계층 간의 통신으로 인해 성능 저하가 발생할 수 있다.
- '단방향 의존성'이 계층화 패턴의 핵심

#### 클라이언트-서버 패턴 (Client-Server pattern)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={ClientServerImg} 
    alt="클라이언트-서버 패턴 구조" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

- 다수의 클라이언트가 서버에 서비스를 요청하면 서버는 클라이언트에게 적절한 서비스를 제공한다 (예 : 이메일, 온라인 어플리케이션 등)
- 자원을 효율적으로 관리할 수 있지만 서버가 다운되면 모든 클라이언트가 영향을 받는다.




#### 파이프-필터 패턴 (Pipe-Filter pattern)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={PipeFilterImg} 
    alt="파이프-필터 패턴 구조" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

- 데이터를 단계별로 처리하기 위해 필터(filter)와 파이프(Pipe)로 구성된 일련의 컴포넌트로 시스템을 설계하는 방법이다.
- 필터는 독립적으로 실행될 수 있으며, 다른 필터와 상호작용하지 않는다. 각 필터는 데이터의 특정 처리를 담당하고, 파이프는 필터 가넹 데이터를 전달하는 역할을 한다.
- 예 : 이미지 데이터가 여러 필터를 통해 처리 되는 것

#### 브로커 패턴 (Broker Pattern)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BrokerPatternImg} 
    alt="브로커 패턴 구조" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

- 컴포넌트 간의 통신을 조정하는 역할을 수행하는 중개자(Broker)가 있는 패턴이다.
- 클라이언트가 서버에 서비스를 요청하면, 브로커가 적절한 서버를 찾아 요청을 전달하고 결과를 클라이언트에게 반환한다.
- 분산 환경 시스템에서 주로 활용된다.
- 분산 시스템에서 클라이언트와 서버 간의 통신을 브로커가 중개하여 시스템의 유연성과 확장성을 높여주는 패턴이다.
- 클라이언트는 브로커를 통해 서버와 통신하므로, 실제 서버의 위치나 통신 방식에 대해 알 필요가 없다.

#### 모델-뷰-컨트롤러 패턴 (Model-View-Controller pattern)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={MvcPatternImg} 
    alt="MVC 패턴 구조" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

- 각 구성 요소가 분리되어 있어 유지보수가 용이하고, 유연성이 높다. 애플리케이션을 세 가지 주요 컴포넌트(Model, View, Controller)로 구성하여 개발하는 방법이다.
- 각 구성 요소가 명확한 역할과 책임을 가지도록 하여 코드의 가독성과 유지보수성을 높일 수 있다.
- 모델(Model) : 애플리케이션의 데이터 및 비즈니스 로직을 담당한다.
- 뷰(View) : 모델의 데이터를 사용자에게 보여주는 역할을 한다. 사용자가 제공한 입력을 받아들인다.
- 컨트롤러(Controller) : 사용자의 입력을 받아 모델과 뷰를 조정(연결)하는 역할을 한다.

#### 마스터-슬레이브 패턴 (Master-Slave pattern)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={MasterSlaveImg} 
    alt="마스터-슬레이브 패턴 구조" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

- 마스터 컴포넌트가 슬레이브 컴포넌트들에게 작업을 분배하고, 슬레이브 컴포넌트들로부터 처리된 결과를 수집하여 최종 결과를 생성하는 패턴이다.
- 마스터는 작업을 조정하고 관리하며, 슬레이브는 실제 작업을 수행한다.
- 장애 허용 시스템(Fault Tolerance System)이나 병렬 컴퓨팅 시스템에서 주로 사용된다.
- 분산 컴퓨팅에서 마스터와 슬레이브라는 두가지 역할을 정의 한다.
- 마스터 (Master) : 작업을 분할하여 각 슬레이브에게 작업을 할당한 후, 슬레이브로부터 결과를 수집하여 종합적인 결과를 산출한다.
- 슬레이브 (Slave) : 마스터로부터 할당된 작업을 수행하고, 그 결과를 마스터에게 반환한다.

### 아키텍처 설계의 시스템 품질 속성
- 아키텍처 설계 시 **반드시 고려해야 하고 목표로 삼아야 할 핵심 기준**들이다.

| 품질 속성 | 개념 및 의미 (Why it matters) | 관련 키워드 |
|---|---|---|
| **가용성**<br/>(Availability) | - 시스템이 장에 없이 정상적으로 운영되는 시간의 비율<br/>- 언제든지 시스템을 사용할 수 있는 정도 | 장애 복구, 이중화, 24/7 운영 |
| **변경 용이성**<br/>(Modifiability) | - 새로운 기능 추가나 변경, 버그 수정 시 시스템의 다른 부분에 영향을 주지 않고 쉽게 수정할 수 있는 정도 | 유지보수, 확장성, 모듈화, 낮은 결합도 |
| **성능**<br/>(Performance) | - 사용자의 요청에 대해 얼마나 빠르게 응답하고 처리할 수 있는지에 대한 능력 | 응답 시간, 처리량(Throughput), 자원 효율성 |
| **보안성**<br/>(Security) | - 인가받지 않은 접근, 사용, 수정, 파괴로부터 시스템과 데이터를 보호하는 능력 | 인증, 권한 부여, 암호화, 무결성 |
| **시험 용이성**<br/>(Testability) | - 시스템이 요구사항을 만족하는지 검증(테스트)가 얼마나 쉬운가에 대한 정도 | 단위 테스트 가능성, 모의 객체(Mock), 디버깅 |
| **사용 편의성**<br/>(Usability) | - 사용자가 시스템을 배우고, 사용하고, 입력을 전달하는 과정이 얼마나 편리한가에 대한 정도 | UI/UX, 직관성, 사용자 매뉴얼 |


### 아키텍처 설계 과정
- 설계 목표 설정
- 시스템 타입 결정
- 스타일 적용 및 커스터마이즈
- 서브 시스템의 기능 및 인터페이스 동작 작성
- 아키텍처 설계 검토 