import WaterfallImg from '@site/static/img/waterfall_model.png';
import PrototypingImg from '@site/static/img/prototyping_model.png';
import SpiralImg from '@site/static/img/spiral_model.png';
import EncapsulationVsDataHidingImg from '@site/static/img/encapsulation_vs_data_hiding.png';

# 요구사항 확인
## 현행 시스템 분석 

## 요구 사항 확인
### 미들웨어 종류 
#### 1)RPC (Remote Procedure Call)
- 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템(체계)
 - ** 정처기 책 표현 "시스템" = 소프트웨어적 체계/방식**
- 쉽게 풀어 다른 서버에 있는 함수를 내 로컬 함수처럼 호출 하는 것
- 핵심 포인트 
    - 네트워크 통신을 숨겨줌 (개발자는 그냥 함수 호출처럼 씀)
    - 동기 방식 (호출하면 결과 올 때까지 대기)
    - 대표 구현 기술 : gRPC, XML-RPC, JSON-RPC

```
// 마치 로컬 함수 호출 하는 것처럼 사용
const result = getUserInfo(userId); // 로컬 함수 호출

// 실제로는 네트워크 건너 다른 서버에서 실행
[내 서버] --네트워크--> [다른 서버에서 getUserInfo 실행] --결과 반환-->
```

#### RPC 구현 방식 비교

| | JSON-RPC | gRPC |
|--|----------|------|
| 포맷 | JSON (텍스트) | Protobuf (바이너리) |
| 속도 | 상대적 느림 | 빠름 |
| 가독성 | 좋음 (사람이 읽기 쉬움) | 나쁨 |
| 용도 | 간단한 API | MSA 서버 간 통신 |

#### 💡 실무 연결: MCP, Tool Call

Claude의 **MCP(Model Context Protocol)**도 JSON-RPC 2.0 기반!

```json
// MCP 요청 예시
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": { "path": "/some/file.txt" }
  },
  "id": 1
}
```

> 결국 **RPC = 함수명 + 파라미터 보내고 → 결과 받기**
> 이 개념을 알면 MCP, OpenAI Function Calling, Claude Tool Use 다 같은 맥락으로 이해됨

#### 2)MOM (Message Oriented Middleware)
- 분산 응용 프로그램 간에 메시지를 보내고 받으면서 데이터를 전달하고 교환할 수 있게 해 주는 미들웨어
- 메세지 지향 미들웨어로 
- 쉽게 말해 메시지 큐에 넣어두고 나중에 처리 하는 것
- 비동기 방식 (메시지 큐에 넣고 나중에 처리)
- 핵심 포인트
 - 비동기 방식 : 보내고 기다리지 않음
 - 메시지 큐 : 중간에 저장소가 있음
 - 송신자/수신자가 동시에 안 떠있어도 됨
 - 대표 예시 : Kafka, RabbitMQ, AWS SQS

```
  // RPC (동기) - 전화 통화
  [나] --전화--> [상대방] "지금 당장 대답해!"
       <--응답--

  // MOM (비동기) - 카톡 메시지
  [나] --메시지--> [큐(카톡서버)] --> [상대방이 나중에 읽음]
  "일단 보내고 난 내 할일 함"
```
#### 💡 실무 연결
 - 주문 들어오면 → 큐에 넣고 → 나중에 배치로 처리
 - 로그 수집 → Kafka로 쌓고 → 분석 시스템이 가져감

#### 3) ORB (Object Request Broker)
- 객체 지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있도록 지원하는 미들웨어 
- 쉽게 말해 다른 서버의 객체를 내 객체처럼 사용할 수 있도록 지원하는 미들웨어 (객체 기반 RPC)
- 대표 구현 기술 : CORBA, RMI
- 핵심 포인트
    - 객체 지향 분산 시스템
    - 서로 다른 언어로 만든 객체도 통신 가능 (Java ↔ C++)
    - CORBA (Common Object Request Broker Architecture)가 대표 표준
    - 요즘은 잘 안 씀 (MSA + REST/gRPC로 대체됨)

```
  // RPC: 원격 "함수" 호출
  getUserInfo(123)

  // ORB: 원격 "객체.메서드" 호출
  remoteUser.getName()
  remoteUser.getAge()
```

#### 4) DB 접속 미들웨어 = 데이터베이스 연결 전담
- 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어 
- 쉽게 말해 데이터베이스 연결을 중간에서 관리
- 핵심 포인트
    - DB 연결/해제 관리
    - 커넥션 풀링 (연결 미리 만들어두고 재사용)
    - 여러 종류 DB 통합 접근 가능 
    - 대표기술 : ODBC, JDBC

```
  [애플리케이션]
        │
        ▼
  [DB 미들웨어]  ← 연결 관리, 풀링, 변환
        │
        ▼
  [Oracle, MySQL, PostgreSQL...]
```
 대표 기술 비교
  |        | ODBC                 | JDBC                 |
  |--------|----------------------|----------------------|
  | 풀네임 | Open DB Connectivity | Java DB Connectivity |
  | 언어   | C/C++ 등 범용        | Java 전용            |
  | 특징   | MS에서 만든 표준     | Java 표준            |

#### 💡 실무 연결
```
  // JDBC 예시 (Java 개발자라면 익숙)
  Connection conn = DriverManager.getConnection(url, user, pw);
  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```
##### 요즘 실무 
```

  [네가 쓰는 것]          [내부적으로 동작]

      JPA/Hibernate
           │
           ▼
      Spring Data JPA    ← 네가 쓰는 레이어
           │
           ▼
        HikariCP         ← 커넥션 풀 (자동 설정)
           │
           ▼
         JDBC            ← DB 미들웨어 (숨겨져 있음)
           │
           ▼
      MySQL Driver       ← application.yml에서 선택
           │
           ▼
         MySQL

Spring Boot에서 선택하는 부분
  # application.yml - 이거 설정하잖아
  spring:
    datasource:
      driver-class-name: com.mysql.cj.jdbc.Driver  # ← 여기서 선택!
      url: jdbc:mysql://localhost:3306/mydb        
```

#### 5) TP 모니터 (Transaction Processing Monitor)
- 분산 시스템의 애플리케이션을 지원하는 미들웨어로 트랜잭션 처리를 감시/제어
- 쉽게 말해 대량 트랜잭션을 안전하게 처리하는 관리자 
```
  [수천 명 동시 요청]
        │
        ▼
    [TP Monitor]  ← 트랜잭션 관리, 부하 분산, 장애 복구
        │
        ├── 트랜잭션 1 ✅
        ├── 트랜잭션 2 ✅
        ├── 트랜잭션 3 ❌ → 롤백!
        └── ...

```
- 핵심 포인트
    - ACID 보장(원자성, 일관성, 고립성, 지속성)
    - 대량 동시처리 (은행,항공 예약 등)
    - 장애 시 롤백/복구
    - 대표 기술 : Tuxedo, CICS, WebSphere, WebLogic

####  💡 실무 비유
 은행 ATM 시스템
  1. 출금 요청 들어옴
  2. 잔액 확인 → 출금 처리 → 잔액 갱신
  3. 중간에 오류? → 전체 롤백 (돈 안 빠짐)

  이걸 수천 명이 동시에 해도 꼬이지 않게 관리
  = TP Monitor

  DB 미들웨어 vs TP Monitor
  |      | DB 미들웨어 | TP Monitor       |
  |------|-------------|------------------|
  | 역할 | DB 연결     | 트랜잭션 관리    |
  | 초점 | 접속/풀링   | ACID/동시성/복구 |
  | 대표 | JDBC, ODBC  | Tuxedo, CICS     |

#### 6) 웹 애플리케이션 서버 (Web Application Server) 
- 웹 애플리케이션을 지원하는 미들웨어
- 쉽게 말해 웹 애플리케이션을 실행할 수 있도록 지원하는 미들웨어
- 핵심 포인트
    - 웹 애플리케이션 실행 환경 제공
    - WAS는 JEE/Jakarta EE 표준을 따름
    - 대표 기술 : Tomcat, JBoss, WebSphere, WebLogic

### 소프트웨어 개발 생명주기 모델
- 소프트웨어를 어떻게 개발할 것인가에 대한 전체적인 흐름

#### 1) 폭포수 모델 
- 앞 단계가 완료될 때까지 대기 상태 
- 완성된 모습을 후반부가 되기 전엔 볼 수 없음
- 고객이 원하는 모습이 아니라면 수정이 어려움

> 요구사항분석 - 설계 - 구현 - 테스팅 - 유지보수 

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={WaterfallImg} 
    alt="폭포수 모델" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 2) 원형모델
 - 점진적으로 시스템을 개발해 나가는 방법
 - 원형(Prototype)을 가능한 빨리 개발한 후 고객과 검증하는것이 목표

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={PrototypingImg} 
    alt="원형 모델" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>
 - 순환 구조 
    - 요구사항정의
    - 원형설계 
    - 원형개발
    - 고객평가
    - 요구사항 조정
    - 완제품

#### 3) 나선형 모델
- 고비용의 시스템 개발이나 큰 시스템 구축 시 효과적
- 프로젝트 수행 시 발생하는 위험을 최소화하려는 목적
- 개발자가 위험을 정확하게 분석하지 못했다면 심각한 문제

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={SpiralImg} 
    alt="나선형 모델" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 애자일 (Agile)
 - 2001년 'Agile 연합' 모임 결성
 - 'Agile 소프트웨어 개발 선언문' 발표
 - 원칙 : 가볍지만 충분한
    > 개발자가 소프트웨어를 어떻게 개발할 것인가에 대한 전체적인 흐름

 ### 애자일 방법론 유형
 #### 1) XP(eXtreme Programming)
- 의사소통 개선과 즉각적 피드백
- 5가지 가치 : 용기 단순성, 의사소통,피드백,존중

#### 2) 스크럼(Scrum)
- 프로젝트 관리를 위한 상호, 점진적 개발 방법론
- XP와 달리 프로젝트 관리가 중점(진행 체계 수립, 역할, 정의에 중점)
- 기존 폭포수 모델이나 프로토타이핑 같은 모델과 달리 모든 LifeCycle을 담지 않는다.
- 5가지 가치 : 확약, 전념, 정직, 존중, 용기 

#### 3) 린(LEAN)
- 도요타사의 대표적인 생산방식
- 인력, 생산 설비 등을 필요한 만큼만 유지하며 생사효율을 극대화하는 방식
- 전적으로 고객관점에서 시스템을 개발하는 방식

### XP(eXtreme Programming)
- 애자일 (Agile)의 가치를 적용한 개발방법론
- 고객의 요구사항은 변경된다 : 고객과 개발팀의 커뮤니케이션 주장
  | 용어 | 내용       |
  |-------------|------------------|
  | 스토리     | 요구사항(고객)    |
  | 스토리 추리   | 스토리를 보고 기간과 강도 결정 (개발자) |
  | 릴리즈  | 고객에게 구현된 제품 배포    |
  | 드라이버 | 코드 작성자 |
  | 파트너 | 드라이버를 도와 조언|

- XP의 5가지 가치
> 단순성, 의사소통, 피드백, 존중, 용기

- XP의 12가지 실천사항

**개발 프로세스**
| 개발 프로세스 | 팀워크 | 코드 품질 | 고객 협업 |
|-------------|--------|----------|----------|
| 계획 게임 | 짝 프로그래밍 | 테스트 우선 개발 | 고객 상주 |
| 짧은 릴리즈 | 코드 공동 소유 | 리팩토링 | 메타포 |
| 지속적 통합 | 주당 40시간 | 단순 설계 | 코딩 표준 |

### 객체지향 방법론
- 소프트웨어 개발 과정은 기존 시스템을 분석하고 이를 표준화된 새로운 시스템 환경으로 전환하는데 초점을 맞추게 되었다.
- 소프트웨어를 개발할 대 작은 단위의 모듈들을 구성하여 추후 이를 재사용하여 소프트웨어의 효율성을 높이자는 생각에서 객체지향 방법론이 발전하게 되었다.
- 여러 객체지향 방법론들이 난립하게 되고 표기법만이라도 통하자는 제안에 의해 UML을 사용하게 되었다. 

#### 1) 객체지향 방법론 개념
- 객체 : 업무 수행을 위한 대상이 되는 사람, 장소, 사물, 사건 및 개념
- 클래스 : 공통 속성과 행위를 가진 객체를 묶어 추상화한 개념
- 캡슐화 : 구현부가 외부에 노출되지 않게 싸여진 상태 
- 데이터 은닉 : 각각의 객체가 자신의 속성(데이터)과 메서드(행위)를 다른 객체에게 숨기고 있는것
- 상속 : 클래스가 가진 속성과 행위를 객체가 물려받는 것 
- 조합 : 다른 객체를 사용하여 객체를 구성하는 것. 보다 복잡한 클래스를 만드는 일종의 조립
- 다형성 : 같은 메서드에 다르게 반응하는 것 
    ```
    // 부모 클래스
    class Animal {
        void makeSound() {
            System.out.println("동물 소리");
        }
    }

    // 자식 클래스들
    class Dog extends Animal {
        @Override
        void makeSound() {
            System.out.println("멍멍!");
        }
    }

    class Cat extends Animal {
        @Override
        void makeSound() {
            System.out.println("야옹~");
        }
    }

    // 사용
    Animal myPet1 = new Dog();  // 부모 타입으로 선언
    Animal myPet2 = new Cat();

    myPet1.makeSound();  // "멍멍!" 출력
    myPet2.makeSound();  // "야옹~" 출력

    // 같은 makeSound() 메서드인데 결과가 다름!
    ```

캡슐화 (Encapsulation) vs 데이터 은닉 (Data Hiding)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={EncapsulationVsDataHidingImg} 
    alt="캡슐화 vs 데이터 은닉 비교" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>
