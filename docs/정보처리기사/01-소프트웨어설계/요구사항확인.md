import WaterfallImg from '@site/static/img/waterfall_model.png';
import PrototypingImg from '@site/static/img/prototyping_model.png';
import SpiralImg from '@site/static/img/spiral_model.png';
import EncapsulationVsDataHidingImg from '@site/static/img/encapsulation_vs_data_hiding.png';

# 요구사항 확인
## 현행 시스템 분석 

## 요구 사항 확인
### 미들웨어 종류 
#### 1)RPC (Remote Procedure Call)
- 클라이언트가 원격에서 동작하는 프로시저를 호출하는 시스템(체계)
 - ** 정처기 책 표현 "시스템" = 소프트웨어적 체계/방식**
- 쉽게 풀어 다른 서버에 있는 함수를 내 로컬 함수처럼 호출 하는 것
- 핵심 포인트 
    - 네트워크 통신을 숨겨줌 (개발자는 그냥 함수 호출처럼 씀)
    - 동기 방식 (호출하면 결과 올 때까지 대기)
    - 대표 구현 기술 : gRPC, XML-RPC, JSON-RPC

```
// 마치 로컬 함수 호출 하는 것처럼 사용
const result = getUserInfo(userId); // 로컬 함수 호출

// 실제로는 네트워크 건너 다른 서버에서 실행
[내 서버] --네트워크--> [다른 서버에서 getUserInfo 실행] --결과 반환-->
```

#### RPC 구현 방식 비교

| | JSON-RPC | gRPC |
|--|----------|------|
| 포맷 | JSON (텍스트) | Protobuf (바이너리) |
| 속도 | 상대적 느림 | 빠름 |
| 가독성 | 좋음 (사람이 읽기 쉬움) | 나쁨 |
| 용도 | 간단한 API | MSA 서버 간 통신 |

#### 💡 실무 연결: MCP, Tool Call

Claude의 **MCP(Model Context Protocol)**도 JSON-RPC 2.0 기반!

```json
// MCP 요청 예시
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": { "path": "/some/file.txt" }
  },
  "id": 1
}
```

> 결국 **RPC = 함수명 + 파라미터 보내고 → 결과 받기**
> 이 개념을 알면 MCP, OpenAI Function Calling, Claude Tool Use 다 같은 맥락으로 이해됨

#### 2)MOM (Message Oriented Middleware)
- 분산 응용 프로그램 간에 메시지를 보내고 받으면서 데이터를 전달하고 교환할 수 있게 해 주는 미들웨어
- 메세지 지향 미들웨어로 
- 쉽게 말해 메시지 큐에 넣어두고 나중에 처리 하는 것
- 비동기 방식 (메시지 큐에 넣고 나중에 처리)
- 핵심 포인트
 - 비동기 방식 : 보내고 기다리지 않음
 - 메시지 큐 : 중간에 저장소가 있음
 - 송신자/수신자가 동시에 안 떠있어도 됨
 - 대표 예시 : Kafka, RabbitMQ, AWS SQS

```
  // RPC (동기) - 전화 통화
  [나] --전화--> [상대방] "지금 당장 대답해!"
       <--응답--

  // MOM (비동기) - 카톡 메시지
  [나] --메시지--> [큐(카톡서버)] --> [상대방이 나중에 읽음]
  "일단 보내고 난 내 할일 함"
```
#### 💡 실무 연결
 - 주문 들어오면 → 큐에 넣고 → 나중에 배치로 처리
 - 로그 수집 → Kafka로 쌓고 → 분석 시스템이 가져감

#### 3) ORB (Object Request Broker)
- 객체 지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있도록 지원하는 미들웨어 
- 쉽게 말해 다른 서버의 객체를 내 객체처럼 사용할 수 있도록 지원하는 미들웨어 (객체 기반 RPC)
- 대표 구현 기술 : CORBA, RMI
- 핵심 포인트
    - 객체 지향 분산 시스템
    - 서로 다른 언어로 만든 객체도 통신 가능 (Java ↔ C++)
    - CORBA (Common Object Request Broker Architecture)가 대표 표준
    - 요즘은 잘 안 씀 (MSA + REST/gRPC로 대체됨)

```
  // RPC: 원격 "함수" 호출
  getUserInfo(123)

  // ORB: 원격 "객체.메서드" 호출
  remoteUser.getName()
  remoteUser.getAge()
```

#### 4) DB 접속 미들웨어 = 데이터베이스 연결 전담
- 애플리케이션과 데이터베이스 서버를 연결해주는 미들웨어 
- 쉽게 말해 데이터베이스 연결을 중간에서 관리
- 핵심 포인트
    - DB 연결/해제 관리
    - 커넥션 풀링 (연결 미리 만들어두고 재사용)
    - 여러 종류 DB 통합 접근 가능 
    - 대표기술 : ODBC, JDBC

```
  [애플리케이션]
        │
        ▼
  [DB 미들웨어]  ← 연결 관리, 풀링, 변환
        │
        ▼
  [Oracle, MySQL, PostgreSQL...]
```
 대표 기술 비교
  |        | ODBC                 | JDBC                 |
  |--------|----------------------|----------------------|
  | 풀네임 | Open DB Connectivity | Java DB Connectivity |
  | 언어   | C/C++ 등 범용        | Java 전용            |
  | 특징   | MS에서 만든 표준     | Java 표준            |

#### 💡 실무 연결
```
  // JDBC 예시 (Java 개발자라면 익숙)
  Connection conn = DriverManager.getConnection(url, user, pw);
  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```
##### 요즘 실무 
```

  [네가 쓰는 것]          [내부적으로 동작]

      JPA/Hibernate
           │
           ▼
      Spring Data JPA    ← 네가 쓰는 레이어
           │
           ▼
        HikariCP         ← 커넥션 풀 (자동 설정)
           │
           ▼
         JDBC            ← DB 미들웨어 (숨겨져 있음)
           │
           ▼
      MySQL Driver       ← application.yml에서 선택
           │
           ▼
         MySQL

Spring Boot에서 선택하는 부분
  # application.yml - 이거 설정하잖아
  spring:
    datasource:
      driver-class-name: com.mysql.cj.jdbc.Driver  # ← 여기서 선택!
      url: jdbc:mysql://localhost:3306/mydb        
```

#### 5) TP 모니터 (Transaction Processing Monitor)
- 분산 시스템의 애플리케이션을 지원하는 미들웨어로 트랜잭션 처리를 감시/제어
- 쉽게 말해 대량 트랜잭션을 안전하게 처리하는 관리자 
```
  [수천 명 동시 요청]
        │
        ▼
    [TP Monitor]  ← 트랜잭션 관리, 부하 분산, 장애 복구
        │
        ├── 트랜잭션 1 ✅
        ├── 트랜잭션 2 ✅
        ├── 트랜잭션 3 ❌ → 롤백!
        └── ...

```
- 핵심 포인트
    - ACID 보장(원자성, 일관성, 고립성, 지속성)
    - 대량 동시처리 (은행,항공 예약 등)
    - 장애 시 롤백/복구
    - 대표 기술 : Tuxedo, CICS, WebSphere, WebLogic

####  💡 실무 비유
 은행 ATM 시스템
  1. 출금 요청 들어옴
  2. 잔액 확인 → 출금 처리 → 잔액 갱신
  3. 중간에 오류? → 전체 롤백 (돈 안 빠짐)

  이걸 수천 명이 동시에 해도 꼬이지 않게 관리
  = TP Monitor

  DB 미들웨어 vs TP Monitor
  |      | DB 미들웨어 | TP Monitor       |
  |------|-------------|------------------|
  | 역할 | DB 연결     | 트랜잭션 관리    |
  | 초점 | 접속/풀링   | ACID/동시성/복구 |
  | 대표 | JDBC, ODBC  | Tuxedo, CICS     |

#### 6) 웹 애플리케이션 서버 (Web Application Server) 
- 웹 애플리케이션을 지원하는 미들웨어
- 쉽게 말해 웹 애플리케이션을 실행할 수 있도록 지원하는 미들웨어
- 핵심 포인트
    - 웹 애플리케이션 실행 환경 제공
    - WAS는 JEE/Jakarta EE 표준을 따름
    - 대표 기술 : Tomcat, JBoss, WebSphere, WebLogic

### 소프트웨어 개발 생명주기 모델
- 소프트웨어를 어떻게 개발할 것인가에 대한 전체적인 흐름

#### 1) 폭포수 모델 
- 앞 단계가 완료될 때까지 대기 상태 
- 완성된 모습을 후반부가 되기 전엔 볼 수 없음
- 고객이 원하는 모습이 아니라면 수정이 어려움

> 요구사항분석 - 설계 - 구현 - 테스팅 - 유지보수 

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={WaterfallImg} 
    alt="폭포수 모델" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 2) 원형모델
 - 점진적으로 시스템을 개발해 나가는 방법
 - 원형(Prototype)을 가능한 빨리 개발한 후 고객과 검증하는것이 목표

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={PrototypingImg} 
    alt="원형 모델" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>
 - 순환 구조 
    - 요구사항정의
    - 원형설계 
    - 원형개발
    - 고객평가
    - 요구사항 조정
    - 완제품

#### 3) 나선형 모델
- 고비용의 시스템 개발이나 큰 시스템 구축 시 효과적
- 프로젝트 수행 시 발생하는 위험을 최소화하려는 목적
- 개발자가 위험을 정확하게 분석하지 못했다면 심각한 문제

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={SpiralImg} 
    alt="나선형 모델" 
    style={{ 
      maxWidth: '500px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 애자일 (Agile)
 - 2001년 'Agile 연합' 모임 결성
 - 'Agile 소프트웨어 개발 선언문' 발표
 - 원칙 : 가볍지만 충분한
    > 개발자가 소프트웨어를 어떻게 개발할 것인가에 대한 전체적인 흐름

 ### 애자일 방법론 유형
 #### 1) XP(eXtreme Programming)
- 의사소통 개선과 즉각적 피드백
- 5가지 가치 : 용기 단순성, 의사소통,피드백,존중

#### 2) 스크럼(Scrum)
- 프로젝트 관리를 위한 상호, 점진적 개발 방법론
- XP와 달리 프로젝트 관리가 중점(진행 체계 수립, 역할, 정의에 중점)
- 기존 폭포수 모델이나 프로토타이핑 같은 모델과 달리 모든 LifeCycle을 담지 않는다.
- 5가지 가치 : 확약, 전념, 정직, 존중, 용기 

#### 3) 린(LEAN)
- 도요타사의 대표적인 생산방식
- 인력, 생산 설비 등을 필요한 만큼만 유지하며 생사효율을 극대화하는 방식
- 전적으로 고객관점에서 시스템을 개발하는 방식

### XP(eXtreme Programming)
- 애자일 (Agile)의 가치를 적용한 개발방법론
- 고객의 요구사항은 변경된다 : 고객과 개발팀의 커뮤니케이션 주장
  | 용어 | 내용       |
  |-------------|------------------|
  | 스토리     | 요구사항(고객)    |
  | 스토리 추리   | 스토리를 보고 기간과 강도 결정 (개발자) |
  | 릴리즈  | 고객에게 구현된 제품 배포    |
  | 드라이버 | 코드 작성자 |
  | 파트너 | 드라이버를 도와 조언|

- XP의 5가지 가치
> 단순성, 의사소통, 피드백, 존중, 용기

- XP의 12가지 실천사항

**개발 프로세스**
| 개발 프로세스 | 팀워크 | 코드 품질 | 고객 협업 |
|-------------|--------|----------|----------|
| 계획 게임 | 짝 프로그래밍 | 테스트 우선 개발 | 고객 상주 |
| 짧은 릴리즈 | 코드 공동 소유 | 리팩토링 | 메타포 |
| 지속적 통합 | 주당 40시간 | 단순 설계 | 코딩 표준 |

### 객체지향 방법론
- 소프트웨어 개발 과정은 기존 시스템을 분석하고 이를 표준화된 새로운 시스템 환경으로 전환하는데 초점을 맞추게 되었다.
- 소프트웨어를 개발할 대 작은 단위의 모듈들을 구성하여 추후 이를 재사용하여 소프트웨어의 효율성을 높이자는 생각에서 객체지향 방법론이 발전하게 되었다.
- 여러 객체지향 방법론들이 난립하게 되고 표기법만이라도 통하자는 제안에 의해 UML을 사용하게 되었다. 

#### 1) 객체지향 방법론 개념
- 객체 : 업무 수행을 위한 대상이 되는 사람, 장소, 사물, 사건 및 개념
- 클래스 : 공통 속성과 행위를 가진 객체를 묶어 추상화한 개념
- 캡슐화 : 구현부가 외부에 노출되지 않게 싸여진 상태 
- 데이터 은닉 : 각각의 객체가 자신의 속성(데이터)과 메서드(행위)를 다른 객체에게 숨기고 있는것
- 상속 : 클래스가 가진 속성과 행위를 객체가 물려받는 것 
- 조합 : 다른 객체를 사용하여 객체를 구성하는 것. 보다 복잡한 클래스를 만드는 일종의 조립
- 다형성 : 같은 메서드에 다르게 반응하는 것 
    ```
    // 부모 클래스
    class Animal {
        void makeSound() {
            System.out.println("동물 소리");
        }
    }

    // 자식 클래스들
    class Dog extends Animal {
        @Override
        void makeSound() {
            System.out.println("멍멍!");
        }
    }

    class Cat extends Animal {
        @Override
        void makeSound() {
            System.out.println("야옹~");
        }
    }

    // 사용
    Animal myPet1 = new Dog();  // 부모 타입으로 선언
    Animal myPet2 = new Cat();

    myPet1.makeSound();  // "멍멍!" 출력
    myPet2.makeSound();  // "야옹~" 출력

    // 같은 makeSound() 메서드인데 결과가 다름!
    ```

캡슐화 (Encapsulation) vs 데이터 은닉 (Data Hiding)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={EncapsulationVsDataHidingImg} 
    alt="캡슐화 vs 데이터 은닉 비교" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 2) SOLID (객체지향 설계 원칙)
- 로버트 마틴이 2000년대 초반에 명명한 것을 마이클 페더스가 두문자어 기억술로 소개한 것으로 객체지향 설계에서 지켜야할 5개의 소프트웨어 개발 원칙이다.

| SOLID | 약어 | 명명 | 설명 |
|----|----|---------------------------------------------|---------------------------------------------|
| S | SRP | 단일책임 원칙(Single responsibility principle) | 한 클래스는 하나의 책임(기능)만 가지도록 설계|
| O | OCP | 개방/폐쇄 원칙(Open/closed principle) | 새로운 변경 사항이 발생했을 때 쉽게 확장 가능 해야하나 객체를 직접적으로 수정하지는 못하게 해야 한다 ( 소프트웨어의 구조를 변경하지 않고 확장할 수 있도록 설계 )|
| L | LSP | 리스코프 치환 원칙(Liskov substitution principle) | 다형성과 관련, 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 부모 타입으로 바꿀 수 있어야 한다. (서브 타입은 슈퍼 타입의 모든 사용에 대체할 수 있도록 설계) |
| I | ISP | 인터페이스 분리 원칙(Interface segregation principle) | 인터페이스를 각각의 목적과 용도에 적합하게 잘 분리해야 한다는 설계 원칙. 클라이언트가 필요하지 않은 인터페이스는 분리하여 설계 |
| D | DIP | 의존성 역전 원칙(Dependency inversion principle) | 구현체보다 추상화된 인터페이스에 의존하도록 설계 한다는 원칙으로 어떤 Class를 참조해서 사용해야 할 때 그 Class를 직접 참조하지 말고 그 대상의 상위 요소인 추상 클래스나 인터페이스를 참조하라는 원칙 |

### 객체지향 방법론 종류
| 기법 | 원리 |
|-----------------------------|-----------------------------|
| 럼바우 - OMT (Object-Modeling-Tecnique) 법| 객체지향 분석 절차 객체(정보)모델링(객체다이어그램) - 동적모델링(상태다이어그램) - 기능모델링 (자료흐름도)| 
| 부치 - Booch 법 | 클래스 다이어그램, 객체 다이어그램, 상태 다이어그램 등의 UML 다이어그램을 사용하여 시스템을 모델링하여 시스템의 구조와 동작을 시각적으로 표현하며 미시적 개발 프로세스와 거시적 개발 프로세 방법을 모두 사용한다.|
| 코드와 요던 - Cord/Yourdon범 | E - R 다이어그램을 사용하여 시스템의 구조와 행위를 분석하고 설계한다. |
| 슐레이어와 멜러 Shlarer/Mellor법 | 객체 지향 시스템을 구조적이고 명확하게 분석하고 설계하기 위한 방법론으로, 특히 실시간 시스템에서의 모델링에 적합하다.|
| 야콥슨 - OOSE (Object-Oriented Software  Engineering) 법 | 유스케이스(Use Case) 를 중심으로 시스템의 기능적 요구사항을 분석하고 모델링한다. |

### UML (Unified Modeling Language) : 표준화된 범용 모델링 언어
- UML은 객체지향 프로그래밍을 위한 표준화된 범용 모델링 언어
- UML은 객체지향 프로그래밍의 개념을 시각적으로 표현할 수 있도록 도와준다.
- 시스템 개발 과정의 광범위한 분야에 활용 가능

#### UML 구성요소

UML은 크게 **사물(Things)**, **관계(Relationships)**, **다이어그램(Diagrams)** 3가지로 구성됩니다.

---

##### 1️⃣ 사물 (Things)
모델을 구성하는 **가장 중요한 기본 요소**로, 다이어그램 안에서 관계가 형성될 수 있는 대상들

| 구분 | 교재 표현 | 설명 | 예시 |
|------|----------|------|------|
| **구조 사물**<br/>(Structural Things) | 시스템의 구조 | 시스템의 개념적, 물리적 요소를 표현 | 클래스, 유스케이스, 컴포넌트, 노드 |
| **행동 사물**<br/>(Behavioral Things) | 시스템의 행위 | 시간과 공간에 따른 요소들의 행위를 표현 | 상호작용, 상태 머신 |
| **그룹 사물**<br/>(Grouping Things) | 개념의 그룹화 | 요소들을 그룹으로 묶어서 표현 | 패키지 |
| **주석 사물**<br/>(Annotational Things) | 부가적인 개념 설명 | 부가적인 설명이나 제약조건을 표현 | 노트 |

**📌 구조 사물 상세**
- **클래스(Class)**: 공통 속성과 행위를 갖는 객체들의 집합
- **유스케이스(Use Case)**: 시스템이 제공하는 기능
- **컴포넌트(Component)**: 물리적으로 존재하는 시스템의 부분
- **노드(Node)**: 물리적으로 존재하는 하드웨어

> 💡 **시험 Tip**: 교재에서는 "시스템의 구조/행위", "개념의 그룹화", "부가적인 개념 설명"으로 표현하지만, 
> 영문 용어(Structural, Behavioral, Grouping, Annotational)도 함께 알아두세요!

---

##### 2️⃣ 관계 (Relationships)
**사물과 사물 사이의 관계**를 표현

교재에서는 크게 **4가지 관계**로 분류합니다:

| 관계 유형 | 표기 | 설명 | 예시 |
|----------|------|------|------|
| **1. 연관 관계**<br/>(Association) | `─────` | 2개 이상의 사물이 서로 관련되어 있음 | 학생 ─── 수강 |
| **2. 의존 관계**<br/>(Dependency) | `- - ->` | 한 사물이 다른 사물을 사용하는 관계 | 주문 - - -> 결제 |
| **3. 일반화 관계**<br/>(Generalization) | `△────` | 상속 관계 (is-a), 부모-자식 관계 | 동물 △─── 강아지 |
| **4. 실체화 관계**<br/>(Realization) | `△- - -` | 인터페이스와 구현 클래스의 관계 | 인터페이스 △- - - 구현클래스 |

---

**📌 연관 관계의 세부 유형**

연관 관계는 다시 **일반 연관**, **집합**, **포함**으로 나뉩니다:

| 세부 유형 | 표기 | 설명 | 예시 |
|----------|------|------|------|
| **일반 연관** (Association) | `─────` | 단순히 서로 관련된 관계 | 학생 ─── 수강 |
| **집합** (Aggregation) | `◇────` | 전체와 부분의 관계 (부분이 독립적) | 컴퓨터 ◇─── 모니터 |
| **포함/합성** (Composition) | `◆────` | 전체와 부분의 관계 (부분이 종속적) | 사람 ◆─── 심장 |

**� 집합 vs 포함 차이**
- **집합(Aggregation)**: 부분이 전체와 **독립적으로 존재 가능** (모니터는 컴퓨터 없이도 존재)
- **포함(Composition)**: 부분이 전체에 **종속적** (심장은 사람 없이 존재 불가, 생명주기 공유)

---

**📌 시험 출제 포인트**

| 관계 | 방향성 | 다중성 | 핵심 키워드 |
|------|--------|--------|------------|
| 연관 | 양방향/단방향 | 1:1, 1:N, N:M | "관련", "참조" |
| 의존 | 단방향 | - | "사용", "일시적" |
| 일반화 | 자식→부모 | - | "상속", "is-a" |
| 실체화 | 구현→인터페이스 | - | "implements" |

> 💡 **암기 팁**: **"연의일실"** (연관, 의존, 일반화, 실체화)

---

##### 3️⃣ 다이어그램 (Diagrams)
사물과 관계를 도형으로 표현한 것

** 정적 모델 - 구조적 다이어그램 (Structural Diagrams)** - 시스템의 정적 구조
| 다이어그램 | 용도 |
|-----------|------|
| **클래스 다이어그램** (Class Diagram) | 클래스, 속성, 메서드, 관계 표현 |
| **오브젝트 다이어그램** (Object Diagram) | 특정 시점의 객체 인스턴스 표현 |
| **컴포넌트 다이어그램** (Component Diagram) | 물리적 컴포넌트와 의존 관계 |
| **배치 다이어그램** (Deployment Diagram) | 하드웨어 노드와 배치 관계 |
| **복합체 구조 다이어그램** (Composite Structure) | 클래스 내부 구조 표현 |
| **패키지 다이어그램** (Package Diagram) | 패키지 간 의존 관계 |

** 동적 모델 - 행위 다이어그램 (Behavioral Diagrams)** - 시스템의 동적 행위
| 다이어그램 | 용도 |
|-----------|------|
| **유스케이스 다이어그램** (Use Case Diagram) | 사용자 관점의 시스템 기능 |
| **순차(시퀀스) 다이어그램** (Sequence Diagram) | 시간 순서에 따른 객체 간 상호작용 |
| **통신(커뮤니케이션) 다이어그램** (Communication Diagram) | 객체 간 메시지 교환 |
| **상태 다이어그램** (State Diagram) | 객체의 상태 변화 |
| **액티비티(활동) 다이어그램** (Activity Diagram) | 업무 흐름이나 처리 과정 |
| **타이밍 다이어그램** (Timing Diagram) | 시간 제약을 명시적으로 표현 |
| **상호작용 개요 다이어그램** (Interaction Overview) | 상호작용 다이어그램 간 제어 흐름 |

