---
id: 애플리케이션설계-2
---

# 애플리케이션 설계 2

import EncapsulationVsDataHidingImg from '@site/static/img/encapsulation_vs_data_hiding.png';
import GofPatternsImg from '@site/static/img/gof_design_patterns_types.png';
import OopConceptsImg from '@site/static/img/oop_concepts_visual.png';

{/* 생성 패턴 (Creational) */}
import AbstractFactoryImg from '@site/static/img/abstract_factory_diagram.png';
import FactoryMethodImg from '@site/static/img/factory_method_diagram.png';
import BuilderPatternImg from '@site/static/img/builder_pattern_diagram.png';
import PrototypePatternImg from '@site/static/img/prototype_pattern_diagram.png';
import SingletonPatternImg from '@site/static/img/singleton_pattern_diagram.png';

{/* 구조 패턴 (Structural) */}
import StructuralPatternsImg from '@site/static/img/structural_pattern_icons.png';
import AdapterPatternImg from '@site/static/img/adapter_pattern_diagram.png';
import DecoratorPatternImg from '@site/static/img/decorator_pattern_diagram.png';
import FacadePatternImg from '@site/static/img/facade_pattern_diagram.png';
import BridgePatternImg from '@site/static/img/bridge_pattern_diagram.png';
import CompositePatternImg from '@site/static/img/composite_pattern_diagram.png';
import FlyweightPatternImg from '@site/static/img/flyweight_pattern_diagram.png';
import ProxyPatternImg from '@site/static/img/proxy_pattern_diagram.png';

## 객체지향 설계 
### 객체(Object))와 객체지향
- 객체(Object)는 객체 데이터(속성)와 해우이(메서드)로 이루어진 것이고 객체지향은 현실 ㅔ계를 객체의 집합으로 보는 개념을 말한다.

### 객체지향 방법론
- 소프트웨어 개발 과정은 기존 시스템을 분석하고 이를 표준화된 새로운 시스템 환경으로 전환하는데 초점을 맞추게 되었다.
- 소프트웨어를 개발할 때 작은 단위의 모듈들을 구성하여 추후 이를 재사용하여 소프트웨어의 효율성을 높이자는 생각에서 객체지향 방법론이 발전하게 되었다.
- 여러 객체지향 방법론들이 난립하게 되고 표기법만이라도 통하자는 제안에 의해 UML을 사용하게 되었다. 

#### 1) 객체지향 방법론 개념

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={OopConceptsImg} 
    alt="객체지향 4대 핵심 개념" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 객체지향 구성요소
- **클래스 (Class)**: 
    - 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀이다. (객체의 설계도, 붕어빵 틀)
    - 객체의 속성(Attribute)과 행위(Behavior)를 정의한다. 
- **객체 (Object)**:
    - 클래스에 정의된 대로 생성된 실체 (Instance 라고도 함).
- **속성 (Attribute)**: 
    - 객체가 가지고 있는 데이터 값.
- **메서드 (Method)**: 
    - 객체가 수행하는 동작/연산.
- **메시지 (Message)**: 
    - 객체 간의 상호작용 수단.

### 객체지향 기법(특징)
- **캡슐화 (Encapsulation)**: 
    - 데이터(속성)와 데이터를 처리하는 함수(메서드)를 하나로 묶는 것.
    - **정보 은닉(Information Hiding)** 의 장점이 있어, 내부 구현을 숨기고 외부에는 필요한 인터페이스만 노출한다. (결합도를 낮추고 응집도를 높임)
    - 예: 알약(캡슐) 안에 무슨 성분이 있는지 몰라도 먹으면 효과가 있음.
- **상속성 (Inheritance)**: 
    - 상위(부모) 클래스의 속성과 메서드를 하위(자식) 클래스가 물려받는 것.
    - 코드 재사용성을 높여준다.
- **다형성 (Polymorphism)**: 
    - 같은 이름의 메서드가 상황에 따라 다르게 동작하거나, 다른 객체에서 다르게 구현되는 것.
    - **오버로딩(Overloading)**: 같은 이름, 다른 매개변수 (ex: print(int), print(String))
    - **오버라이딩(Overriding)**: 부모 메서드를 자식이 재정의 (ex: 동물.울다() -> 강아지: 멍멍, 고양이: 야옹)
- **추상화 (Abstraction)**: 
    - 불필요한 부분을 생략하고 객체의 가장 중요한 속성과 행위에만 중점을 두어 모델화하는 것.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={EncapsulationVsDataHidingImg} 
    alt="캡슐화와 정보 은닉의 차이" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 객체지향 설계 원칙 (SOLID)
- **SRP (Single Responsibility Principle, 단일 책임 원칙)**: 클래스는 단 하나의 책임만 가져야 한다.
- **OCP (Open-Closed Principle, 개방-폐쇄 원칙)**: 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다. (기존 코드를 손대지 않고 기능 추가 가능해야 함)
- **LSP (Liskov Substitution Principle, 리스코프 치환 원칙)**: 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다. (부모 타입 자리에 자식 인스턴스를 넣어도 문제가 없어야 함)
- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**: 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. (큰 인터페이스 하나보다 작은 인터페이스 여러 개가 낫다)
- **DIP (Dependency Inversion Principle, 의존 역전 원칙)**: 구체적인 클래스보다 추상적인 인터페이스나 상위 클래스에 의존해야 한다.

### 객체지향 분석 방법론 종류
- **Rumbaugh(럼바우) 방법론**: 
    - 가장 일반적으로 사용되는 방법론
    - 분석 활동을 **객체 모델**, **동적 모델**, **기능 모델**로 나누어 수행 (객동기)
    - 객체 모델링(Object Modeling): 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
    - 동적 모델링(Dynamic Modeling): 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
    - 기능 모델링(Functional Modeling): 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
- **Booch(부치) 방법론**: 
    - 미시적(Micro) 및 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법
    - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
- **Jacobson(제이콥슨) 방법론**: 
    - 유스케이스(Use Case)를 강조하여 사용하는 분석 방법
- **Coad와 Yourdon 방법론**: 
    - E-R 다이어그램을 사용하여 객체의 행위를 모델링 
    - 객체 식별, 구조 식별, 주제 정의, 속성 및 인스턴스 연결 정의, 연산 및 메시지 연결 정의 등의 과정으로 구성
- **Wirfs-Brock(워프스-브록) 방법론**: 
    - 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행 

---

## 디자인 패턴 (Design Pattern) 🎨

### 디자인 패턴 개요
디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 **패턴**이다.
- "선배 개발자들이 삽질 끝에 찾아낸 족보" 같은 것.
- **GoF (Gang of Four)** 디자인 패턴이 가장 유명하다. (총 23개)

### 디자인 패턴 구성요소
1. **패턴 이름**: 패턴을 부를 때 사용하는 이름 (예: 싱글톤)
2. **문제 (Problem)**: 언제 이 패턴을 써야 하는지 (상황 설명)
3. **해법 (Solution)**: 설계를 구성하는 요소들과 그 관계 (설계도)
4. **결과 (Consequence)**: 패턴을 적용했을 때의 이점과 장단점

### GoF 디자인 패턴 분류
GoF 디자인 패턴은 크게 **생성(Creational)**, **구조(Structural)**, **행위(Behavioral)** 패턴으로 나뉩니다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={GofPatternsImg} 
    alt="GoF 디자인 패턴 3가지 분류 (생성, 구조, 행위)" 
    style={{ 
      maxWidth: '800px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 1. 생성 패턴 (Creational Patterns)
- 객체 **생성**에 관련된 패턴.
- 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.
- 주요 패턴 5가지: **추상 팩토리, 팩토리 메서드, 빌더, 프로토타입, 싱글톤**



---

### 1) 추상 팩토리 (Abstract Factory)
- **개념**: 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는 객체들의 **그룹(Group)**을 생성하는 패턴.
- **특징**: "관련된 객체들의 집합"을 생성할 때 유용함. (예: 윈도우 테마 vs 맥 테마 바꿀 때 버튼, 스크롤바, 창이 세트로 바뀜)
- **비유**: 나이키 공장에선 나이키 신발+나이키 옷을 만들고, 아디다스 공장에선 아디다스 신발+아디다스 옷을 만든다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={AbstractFactoryImg} 
    alt="추상 팩토리 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
// 1. 추상 제품 (버튼)
interface Button { void paint(); }

// 2. 구체적 제품 (윈도우 버튼, 맥 버튼)
class WinButton implements Button { public void paint() { System.out.println("윈도우 버튼"); } }
class MacButton implements Button { public void paint() { System.out.println("맥 버튼"); } }

// 3. 추상 팩토리
interface GUIFactory { Button createButton(); }

// 4. 구체적 팩토리
class WinFactory implements GUIFactory { public Button createButton() { return new WinButton(); } }
class MacFactory implements GUIFactory { public Button createButton() { return new MacButton(); } }

// 사용
GUIFactory factory = new WinFactory(); // 윈도우 공장 가동
Button btn = factory.createButton(); // 윈도우 버튼 생성됨
btn.paint();
```

### 2) 팩토리 메서드 (Factory Method)
- **개념**: 객체 생성 처리를 캡슐화하고, 구체적인 생성 과정은 **서브 클래스(SubClass)**로 분리하는 패턴.
- **특징**: 부모 클래스는 "객체를 생성한다"는 인터페이스만 정의하고, 실제 "어떤 객체"를 만들지는 자식 클래스가 결정함. (Virtual Constructor)
- **비유**: 붕어빵 틀(부모)은 똑같은데, 팥을 넣을지 슈크림을 넣을지(자식)에 따라 생성되는 붕어빵이 다름.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={FactoryMethodImg} 
    alt="팩토리 메서드 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 3) 빌더 (Builder)
- **개념**: 작게 분리된 인스턴스를 건축 하듯이 **단계별로 조립**하여 전체 객체를 만드는 패턴.
- **특징**: 객체의 생성 과정과 표현 방법을 분리한다. 인자가 많거나 복잡한 객체 생성 시 유용.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BuilderPatternImg} 
    alt="빌더 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
// 빌더 패턴 사용 예 (체이닝 방식)
User user = new User.Builder()
    .setName("홍길동")
    .setAge(30)
    .build();
```

### 4) 프로토타입 (Prototype)
- **개념**: 원본 객체를 **복제(Clone)**하는 방법으로 객체를 생성하는 패턴.
- **특징**: 비용이 많이 드는 객체의 인스턴스를 새로 생성하는 대신, 기존 인스턴스를 복사하여 사용.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={PrototypePatternImg} 
    alt="프로토타입 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
class Sheep implements Cloneable {
    private String name;
    public Sheep(String name) { this.name = name; }
    public void setName(String name) { this.name = name; }

    // 복제 메서드
    @Override
    public Sheep clone() {
        try {
            return (Sheep) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }
}

// 사용
Sheep dolly = new Sheep("Dolly");
Sheep clonedSheep = dolly.clone(); // 복제! (new Sheep() 안 함)
clonedSheep.setName("Molly"); // 이름만 변경
```

### 5) 싱글톤 (Singleton)
- **개념**: 전역 변수를 사용하지 않고 **객체를 하나만 생성**하도록 하여, 생성된 객체를 어디서든지 참조할 수 있도록 하는 패턴.
- **특징**: 메모리 낭비 방지, 데이터 공유 용이.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={SingletonPatternImg} 
    alt="싱글톤 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
class SystemConfig {
    // 1. 자기 자신의 인스턴스를 하나만 가짐 (static)
    private static SystemConfig instance;

    // 2. 생성자를 private으로 막음 (외부에서 new 금지)
    private SystemConfig() {}

    // 3. 오직 이 메서드로만 접근 가능
    public static SystemConfig getInstance() {
        if (instance == null) {
            instance = new SystemConfig();
        }
        return instance;
    }
}

// 사용
SystemConfig config1 = SystemConfig.getInstance();
SystemConfig config2 = SystemConfig.getInstance();
// config1 == config2 (같은 객체임!)
```

---

#### 💡 [면접 대비] 생성 패턴 5대장 한눈에 비교하기

| 패턴 이름 | 핵심 키워드 | 언제 쓰나요? (실무/비유) | 특징 및 차이점 |
| :--- | :--- | :--- | :--- |
| **추상 팩토리**<br/>(Abstract Factory) | **관련 객체 군집** | **"테마 변경"** (윈도우/맥 테마에 따라 버튼, 창, 스크롤바가 세트로 바뀔 때) | 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관된 객체들의 집합을 생성. |
| **팩토리 메서드**<br/>(Factory Method) | **상속 & 오버라이딩** | **"프레임워크"** (스프링 프레임워크가 빈(Bean)을 생성할 때, 구체적인 생성은 하위 클래스에 위임) | 객체 생성 처리를 서브 클래스로 분리하여 캡슐화. (가상 생성자) |
| **빌더**<br/>(Builder) | **복잡한 단계** | **"수제 버거 주문", "여행 패키지"** (재료가 많고 순서가 복잡할 때 단계별로 조립) | 복잡한 인스턴스를 조립하여 만듦. 생성 과정과 표현 방법을 분리. |
| **프로토타입**<br/>(Prototype) | **복제 (Clone)** | **"게임 몬스터 소환"** (기본 몬스터 하나 만들어두고 계속 복제해서 떼거지로 생성) | 원본 객체를 복제하여 새 객체를 생성 (`clone`). 비용이 큰 객체 생성 시 유리. |
| **싱글톤**<br/>(Singleton) | **유일한 인스턴스** | **"프린터 스풀러 / DB 커넥션 풀"** (전 시스템에서 딱 하나만 있어야 하는 관리자) | 전역에서 접근 가능한 유일한 객체를 보장. 메모리 낭비 방지. |

---

### 2. 구조 패턴 (Structural Patterns)
- **개념**: 클래스나 객체를 조합하여 **더 큰 구조**를 만드는 패턴. 서로 다른 인터페이스를 가진 객체들을 묶어서 새로운 기능을 제공하거나 인터페이스를 통일함.
- **핵심 패턴 7가지**: **어댑터, 데코레이터, 파사드, 브리지, 컴포지트, 플라이웨이트, 프록시**

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={StructuralPatternsImg} 
    alt="구조 패턴 핵심 아이콘" 
    style={{ 
      maxWidth: '800px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 1) 어댑터 (Adapter)
- **개념**: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 **변환**해주는 패턴.
- **비유**: **110v 플러그 -> 220v 돼지코 변환기**
- **특징**: 기존 클래스를 수정하지 않고도 타겟 인터페이스에 맞춰 사용할 수 있게 해줌.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={AdapterPatternImg} 
    alt="어댑터 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
// 1. 이미 있는 110v 플러그 (수정 불가)
class Plug110V { public void connect() { System.out.println("110v 연결됨"); } }

// 2. 우리가 필요한 건 220v
interface Plug220V { void connect220V(); }

// 3. 어댑터 (돼지코)
class Adapter implements Plug220V {
    private Plug110V plug110;
    public Adapter(Plug110V plug) { this.plug110 = plug; }
    
    @Override
    public void connect220V() {
        System.out.print("돼지코 변환 중... ");
        plug110.connect(); // 110v 메서드 호출
    }
}
```

### 2) 데코레이터 (Decorator)
- **개념**: 객체의 결합을 통해 **기능을 동적으로 유연하게 확장**할 수 있게 해주는 패턴.
- **비유**: **커피(기본) + 우유 추가(라떼) + 시럽 추가(바닐라 라떼)**
- **특징**: 상속(Inheritance)보다 유연하게 기능을 확장할 수 있다. (러시아 인형 마트료시카처럼 계속 감싸는 구조)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={DecoratorPatternImg} 
    alt="데코레이터 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
// 1. 기본 커피
interface Coffee { String brew(); }
class PlainCoffee implements Coffee {
    public String brew() { return "커피"; }
}

// 2. 데코레이터 (토핑 추가)
class MilkDecorator implements Coffee {
    private Coffee coffee;
    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }
    
    public String brew() {
        return coffee.brew() + " + 우유"; // 기능 추가!
    }
}

// 사용
Coffee myCoffee = new PlainCoffee(); // "커피"
myCoffee = new MilkDecorator(myCoffee); // "커피 + 우유"
```

### 3) 파사드 (Facade)
- **개념**: 복잡한 서브 시스템들의 인터페이스를 통합하여, 사용하기 쉬운 **하나의 간략한 인터페이스**를 제공하는 패턴.
- **비유**: **리모컨의 '전원' 버튼** (누르면 TV, 셋탑, 스피커가 알아서 다 켜짐)
- **특징**: 클라이언트와 서브 시스템 간의 결합도를 낮춤. (복잡한 건 파사드 뒤에 숨김)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={FacadePatternImg} 
    alt="파사드 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
// 복잡한 서브 시스템들
class CPU { void freeze() {} void jump() {} }
class Memory { void load() {} }
class HardDrive { void read() {} }

// 파사드 (단순화된 인터페이스)
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hdd;
    public ComputerFacade() { /* 생성 */ }

    // 복잡한 부팅 과정을 메서드 하나로 퉁칩니다.
    public void startComputer() {
        cpu.freeze();
        memory.load();
        hdd.read();
        cpu.jump();
        System.out.println("컴퓨터 부팅 완료!");
    }
}
```

### 4) 브리지 (Bridge)
- **개념**: **구현부와 추상층을 분리**하여 독자적으로 확장할 수 있게 하는 패턴.
- **특징**: 기능 클래스 계층과 구현 클래스 계층을 연결(Bridge)한다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BridgePatternImg} 
    alt="브리지 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
// 구현부: 색상
interface Color { void applyColor(); }
class Red implements Color { public void applyColor() { System.out.println("빨강"); } }

// 추상부: 모양
abstract class Shape {
    protected Color color;
    public Shape(Color c) { this.color = c; } // Bridge 연결
    abstract void draw();
}
class Circle extends Shape {
    public Circle(Color c) { super(c); }
    public void draw() { 
        System.out.print("원 그리기: "); 
        color.applyColor(); 
    }
}
```

### 5) 컴포지트 (Composite)
- **개념**: 부분과 전체를 동일하게 취급하여 **트리 구조**로 구성하는 패턴.
- **비유**: **파일 탐색기 (폴더 = 파일들의 집합)**
- **특징**: 단일 객체와 복합 객체를 구분 없이 다룰 수 있음.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={CompositePatternImg} 
    alt="컴포지트 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 6) 플라이웨이트 (Flyweight)
- **개념**: 인스턴스를 가능한 한 **공유(Sharing)**하여 메모리를 절약하는 패턴.
- **특징**: 'Flyweight(가벼운급)'라는 이름처럼 가볍게 만듦. 같은 것은 공유해서 씀.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={FlyweightPatternImg} 
    alt="플라이웨이트 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 7) 프록시 (Proxy)
- **개념**: 실제 객체에 대한 접근을 제어하기 위해 **대리인(Proxy) 객체**를 두는 패턴.
- **특징**: 접근 제어, 지연 로딩 등에 사용됨.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={ProxyPatternImg} 
    alt="프록시 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>
