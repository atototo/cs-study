---
id: 애플리케이션설계-2
---

# 애플리케이션 설계 2

import EncapsulationVsDataHidingImg from '@site/static/img/encapsulation_vs_data_hiding.png';
import GofPatternsImg from '@site/static/img/gof_design_patterns_types.png';
import OopConceptsImg from '@site/static/img/oop_concepts_visual.png';

{/* 생성 패턴 (Creational) */}
import AbstractFactoryImg from '@site/static/img/abstract_factory_diagram.png';
import FactoryMethodImg from '@site/static/img/factory_method_diagram.png';
import BuilderCarConceptKrImg from '@site/static/img/builder_car_concept_kr.png';
import BuilderDirectorUmlKrImg from '@site/static/img/builder_director_uml_kr.png';
import PrototypePatternImg from '@site/static/img/prototype_pattern_diagram.png';
import SingletonPatternImg from '@site/static/img/singleton_pattern_diagram.png';

{/* 구조 패턴 (Structural) */}
import StructuralPatternsImg from '@site/static/img/structural_pattern_icons.png';
import AdapterPatternImg from '@site/static/img/adapter_pattern_diagram.png';
import DecoratorPatternImg from '@site/static/img/decorator_pattern_diagram.png';
import FacadePatternImg from '@site/static/img/facade_pattern_diagram.png';
import BridgePatternImg from '@site/static/img/bridge_pattern_diagram.png';
import CompositePatternImg from '@site/static/img/composite_pattern_diagram.png';
import FlyweightPatternImg from '@site/static/img/flyweight_pattern_diagram.png';
import ProxyPatternImg from '@site/static/img/proxy_pattern_diagram.png';

## 객체지향 설계 
### 객체(Object))와 객체지향
- 객체(Object)는 객체 데이터(속성)와 행위(메서드)로 이루어진 것이고 객체지향은 현실 세계를 객체의 집합으로 보는 개념을 말한다.

### 객체지향 방법론
- 소프트웨어 개발 과정은 기존 시스템을 분석하고 이를 표준화된 새로운 시스템 환경으로 전환하는데 초점을 맞추게 되었다.
- 소프트웨어를 개발할 때 작은 단위의 모듈들을 구성하여 추후 이를 재사용하여 소프트웨어의 효율성을 높이자는 생각에서 객체지향 방법론이 발전하게 되었다.
- 여러 객체지향 방법론들이 난립하게 되고 표기법만이라도 통일하자는 제안에 의해 UML을 사용하게 되었다. 

#### 1) 객체지향 방법론 개념

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={OopConceptsImg} 
    alt="객체지향 4대 핵심 개념" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 객체지향 구성요소
- **클래스 (Class)**: 
    - 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀이다. (객체의 설계도, 붕어빵 틀)
    - 객체의 속성(Attribute)과 행위(Behavior)를 정의한다. 
- **객체 (Object)**:
    - 클래스에 정의된 대로 생성된 실체 (Instance 라고도 함).
- **속성 (Attribute)**: 
    - 객체가 가지고 있는 데이터 값.
- **메서드 (Method)**: 
    - 객체가 수행하는 동작/연산.
- **메시지 (Message)**: 
    - 객체 간의 상호작용 수단.

### 객체지향 기법(특징)
- **캡슐화 (Encapsulation)**: 
    - 데이터(속성)와 데이터를 처리하는 함수(메서드)를 하나로 묶는 것.
    - **정보 은닉(Information Hiding)** 의 장점이 있어, 내부 구현을 숨기고 외부에는 필요한 인터페이스만 노출한다. (결합도를 낮추고 응집도를 높임)
    - **목적**: 단순히 묶는 것뿐만 아니라, **"객체의 상태를 외부에서 직접 변경하지 못하게 막는 것"** 이다. (주로 `private` 접근 제어자 사용)
    - 이를 통해 객체의 **자율성**을 보장하고 유지보수성을 높인다.
    - 예: 알약(캡슐) 안에 무슨 성분이 있는지 몰라도 먹으면 효과가 있음.
    - **[심화] 진정한 캡슐화 ("묻지 말고 시켜라", Tell, Don't Ask)**:
        - 단순히 `private` 필드에 `Getter/Setter`를 기계적으로 만드는 것은 **"단순한 문법적 캡슐화"**  이자 **"데이터 전달 객체(DTO)"** 일 뿐, 진정한 객체지향적 캡슐화가 아니다.
        - **관점의 전환**: 객체로부터 데이터를 가져와서(`get`) 외부에서 처리(`set`)하지 말고, 객체에게 **"처리해줘(`method`)"** 라고 명령해야 한다.
        ```java
        // ❌ 나쁜 예: 외부에서 로직을 수행 (수동적인 객체)
        class Account {
            private int balance;
            public int getBalance() { return balance; }
            public void setBalance(int val) { this.balance = val; }
        }
        // 사용: account.setBalance(account.getBalance() - 1000); -> 정보 은닉 위배!

        // ⭕ 좋은 예: 객체가 스스로 처리 (자율적인 객체)
        class Account {
            private int balance;
            // '출금'이라는 행위만 노출하고 내부 로직은 숨김
            public void withdraw(int amount) {
                if (this.balance >= amount) {
                    this.balance -= amount;
                } else {
                    System.out.println("잔액 부족");
                }
            }
        }
        // 사용: account.withdraw(1000); -> "돈 줘" (내부 사정은 모름)
        ```
        - 이처럼 캡슐화의 본질은 변수를 가리는 것을 넘어, **"구현의 세부 사항(로직)을 감추어 유지보수성을 극대화하는 것"** 이다.
 <div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={EncapsulationVsDataHidingImg} 
    alt="캡슐화와 정보 은닉의 차이" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>       
- **상속성 (Inheritance)**: 
    - 상위(부모) 클래스의 속성과 메서드를 하위(자식) 클래스가 물려받는 것.
    - 코드 재사용성을 높여준다.
    - **주의점**: 상속은 클래스 간의 **결합도(Coupling)** 를 높이는 치명적인 단점이 있다. 부모가 변경되면 자식에게도 영향이 간다.
    - **실무 Tip**: 정보처리기사나 면접에서는 "상속보다는 **합성(Composition)** 을 선호하라"는 원칙을 언급하면 좋다.
    - **[심화] 상속(Inheritance) vs 합성(Composition)**:
        - **상속의 한계 ("is-a")**: 부모-자식 간의 강한 결합(Coupling)으로 인해 부모 변경 시 자식에게 영향이 가며(깨지기 쉬운 기반 클래스), 유연성이 떨어진다. (예: `타조`가 `새`를 상속받았는데 `새`에 `날다()` 메서드가 추가되면 곤란해짐)
        - **합성의 장점 ("has-a")**: 객체가 다른 객체를 **부품(변수)** 으로 포함하여 기능을 사용하는 방식. 결합도가 낮고 런타임에 부품을 교체할 수 있어 유연하다.
        - **코드 비교**:
        ```java
        // ❌ 상속 방식 (강한 결합)
        class Car extends Engine { // 차가 엔진을 상속? (논리적 오류 & 수정 어려움)
            void drive() {
                start(); // 부모 메서드 직접 호출
                System.out.println("운전 시작!");
            }
        }

        // ⭕ 합성 방식 (유연한 결합, 추천)
        class Car {
            private Engine engine; // 엔진을 부품으로 가짐 (has-a)

            public Car(Engine engine) {
                this.engine = engine; // 생성자로 주입받음 (DI)
            }
            void drive() {
                engine.start(); // 엔진에게 일을 시킴
                System.out.println("운전 시작!");
            }
        }
        ```
        - **결론**: 상속은 컴파일 시점에 관계가 고정되지만, 합성은 **런타임에 동적으로 변경** 이 가능하다. 변화에 유연한 설계를 위해 실무에서는 **합성** 을 우선 고려해야 한다.
- **다형성 (Polymorphism)**: 
    - 같은 이름의 메서드가 상황에 따라 다르게 동작하거나, 다른 객체에서 다르게 구현되는 것.
    - **오버로딩(Overloading)**: 같은 이름, 다른 매개변수 (ex: print(int), print(String))
    - **오버라이딩(Overriding)**: 부모 메서드를 자식이 재정의 (ex: 동물.울다() -> 강아지: 멍멍, 고양이: 야옹)
    - **본질**: **"역할(Interface)과 구현(Implementation)의 분리"**. 
    - **예시**: 운전자는 '자동차'라는 인터페이스만 알면, 그게 아반떼든 테슬라든(구현체) 운전할 수 있다.
    - **기술적 요소**: **동적 바인딩(Dynamic Binding)** 을 통해 런타임에 어떤 객체의 메서드가 실행될지 결정된다.
- **추상화 (Abstraction)**: 
    - 불필요한 부분을 생략하고 객체의 가장 중요한 속성과 행위에만 중점을 두어 모델화하는 것.
    - 단순히 생략하는 것이 아니라, 여러 객체의 **"공통적인 속성과 기능을 추출하는 과정"** 이다.
    - **구분**: `추상 클래스(Abstract Class)`와 `인터페이스(Interface)`
    - **[심화] 추상 클래스 vs 인터페이스**:
        - **추상 클래스 ("유전적 확장")**: 부모의 특징을 물려받고 확장하는 것이 목적. (`extends`)
            - `final` 메서드: 컴파일러가 자식의 메서드 오버라이딩(재정의)을 금지하여 부모의 핵심 로직을 보호한다.
            ```java
            abstract class Animal {
                // 1. 일반 메서드 (재정의 가능)
                void breathe() { System.out.println("숨쉬기"); }
                // 2. 추상 메서드 (반드시 재정의)
                abstract void sound();
                // 3. final 메서드 (재정의 금지!)
                final void species() { System.out.println("생물입니다."); }
            }
            ```
        - **인터페이스 ("기능적 계약")**: 계층과 상관없이 "이 기능을 할 수 있다(Can-do)"를 보장. (`implements`)
            - 변수는 `public static final` 상수로만 존재하며, 다중 구현이 가능하다.
            ```java
            interface Flyable { void fly(); } // 날 수 있는
            interface Swimable { void swim(); } // 수영할 수 있는
            // 다중 구현 예시
            class Duck implements Flyable, Swimable {
                public void fly() { /* 구현 */ }
                public void swim() { /* 구현 */ }
            }
            ```
        - **비교 요약**:
            | 구분 | 추상 클래스 (`abstract`) | 인터페이스 (`interface`) |
            | :--- | :--- | :--- |
            | **목적** | **확장 (Is-A)** | **계약 (Can-Do)** |
            | **다중상속** | 불가능 (단일 상속) | **가능 (다중 구현)** |
            | **제어** | `final` 메서드로 재정의 방지 가능 | 기본적으로 재정의가 목적 |
            | **필드** | 상태(변수) 가질 수 있음 | 상수(`static final`)만 가능 |
        - **(참고) final의 3단 활용**: `final class`(상속 금지), `final method`(오버라이딩 금지), `final variable`(값 변경 금지/상수).



### 객체지향 설계 원칙 (SOLID)
- **SRP (Single Responsibility Principle, 단일 책임 원칙)**: 클래스는 단 하나의 책임만 가져야 한다.
- **OCP (Open-Closed Principle, 개방-폐쇄 원칙)**: 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다. (기존 코드를 손대지 않고 기능 추가 가능해야 함)
- **LSP (Liskov Substitution Principle, 리스코프 치환 원칙)**: 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다. (부모 타입 자리에 자식 인스턴스를 넣어도 문제가 없어야 함)
- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**: 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. (큰 인터페이스 하나보다 작은 인터페이스 여러 개가 낫다)
- **DIP (Dependency Inversion Principle, 의존 역전 원칙)**: 구체적인 클래스보다 추상적인 인터페이스나 상위 클래스에 의존해야 한다.

### 객체지향 분석 방법론 종류
- **Rumbaugh(럼바우) 방법론**: 
    - 가장 일반적으로 사용되는 방법론
    - 분석 활동을 **객체 모델**, **동적 모델**, **기능 모델**로 나누어 수행 (객동기)
    - 객체 모델링(Object Modeling): 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것
    - 동적 모델링(Dynamic Modeling): 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
    - 기능 모델링(Functional Modeling): 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
- **Booch(부치) 방법론**: 
    - UML 다이어그램을 사용하여 객체의 구조와 동작을 모델링
    - 미시적(Micro) 및 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법
    - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
- **Jacobson(제이콥슨) 방법론**: 
    - 유스케이스(Use Case)를 강조하여 사용하는 분석 방법
- **Coad와 Yourdon 방법론**: 
    - E-R 다이어그램을 사용하여 객체의 행위를 모델링 
    - 객체 식별, 구조 식별, 주제 정의, 속성 및 인스턴스 연결 정의, 연산 및 메시지 연결 정의 등의 과정으로 구성
- **Wirfs-Brock(워프스-브록) 방법론**: 
    - 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행 

---

## 디자인 패턴 (Design Pattern) 🎨

### 디자인 패턴 개요
디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 **패턴**이다.
- "선배 개발자들이 삽질 끝에 찾아낸 족보" 같은 것.
- **GoF (Gang of Four)** 디자인 패턴이 가장 유명하다. (총 23개)

### 디자인 패턴 구성요소
1. **패턴 이름**: 패턴을 부를 때 사용하는 이름 (예: 싱글톤)
2. **문제 (Problem)**: 언제 이 패턴을 써야 하는지 (상황 설명)
3. **해법 (Solution)**: 설계를 구성하는 요소들과 그 관계 (설계도)
4. **결과 (Consequence)**: 패턴을 적용했을 때의 이점과 장단점

### GoF 디자인 패턴 분류
GoF 디자인 패턴은 크게 **생성(Creational)**, **구조(Structural)**, **행위(Behavioral)** 패턴으로 나뉩니다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={GofPatternsImg} 
    alt="GoF 디자인 패턴 3가지 분류 (생성, 구조, 행위)" 
    style={{ 
      maxWidth: '800px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 1. 생성 패턴 (Creational Patterns)
- 객체 **생성**에 관련된 패턴.
- 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.
- 주요 패턴 5가지: **추상 팩토리, 팩토리 메서드, 빌더, 프로토타입, 싱글톤**



---


### 1) 팩토리 메서드 (Factory Method)
- **정의 (Definition)**: 객체 생성을 위한 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 만들지는 **서브 클래스(SubClass)가 결정**하게 하는 패턴입니다. 부모 클래스에서는 **상속을 통한 확장**을 열어두고, 자식 클래스에서 구체적인 객체 생성을 책임지도록 위임합니다. (가상 생성자, Virtual Constructor)
- **핵심 목표**: 객체 생성 코드를 비즈니스 로직과 분리하여 **결합도(Coupling)를 낮추는 것**.
- **정보처리기사 핵심 키워드**:
    - **동적 바인딩(Dynamic Binding)**: 런타임에 어떤 서브 클래스의 `create` 메서드가 호출될지 결정됩니다.
    - **캡슐화(Encapsulation)**: 구체적인 제품 객체 생성 과정을 서브 클래스 내부로 숨깁니다.
    - **상속(Inheritance)**: 부모의 메서드를 자식이 오버라이딩하여 생성 로직을 구체화합니다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={require('@site/static/img/factory_method_burger_uml.png').default} 
    alt="팩토리 메서드 패턴 구조도 (버거 가게 비유)" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**단순 팩토리(Simple Factory)와 비교 (면접 단골 질문)**
- **단순 팩토리 (Not a Pattern)**: 단순히 `if-else` 문으로 타입을 구분하여 객체를 생성하는 방식.
    - *문제점*: 새로운 메뉴(치킨 버거)가 추가되면, 팩토리 클래스의 `if` 문을 수정해야 하므로 **OCP(개방-폐쇄 원칙)**를 위배하게 됩니다.
    ```java
    // 단순 팩토리 예시 (OCP 위반)
    class SimpleBurgerFactory {
        public Burger createBurger(String type) {
            if (type.equals("Cheese")) return new CheeseBurger();
            else if (type.equals("Veggie")) return new VeggieBurger();
            // 메뉴 추가 시 여기 코드를 계속 수정해야 함! 😱
            else return null;
        }
    }
    ```
- **팩토리 메서드 패턴**: 생성 메서드를 **추상 메서드**로 선언하고, 이를 상속받은 자식 클래스가 각자의 방식대로 객체를 생성.
    - *장점*: 새로운 메뉴가 추가되어도 기존 `Restaurant` 코드는 전혀 수정할 필요가 없습니다. 그냥 `ChickenBurgerRestaurant` 클래스만 하나 더 만들면 됩니다. (OCP 준수)

**예시 코드 (Java) - 팩토리 메서드 (단일 제품)**
```java
// 1. 제품 인터페이스
interface Burger { void eat(); }

// 2. 구체적인 제품
class CheeseBurger implements Burger { public void eat() { System.out.println("치즈버거 냠냠"); } }

// 3. 생산자 (팩토리 메서드 포함)
abstract class Restaurant {
    public abstract Burger createBurger(); // 팩토리 메서드

    // 공통 기능 (Template Method 패턴 활용)
    public void orderBurger() {
        Burger burger = createBurger();
        burger.eat();
    }
}

class CheeseBurgerRestaurant extends Restaurant {
    public Burger createBurger() { return new CheeseBurger(); }
}
```
---

### [심화] 패턴의 진화: 단일 메뉴에서 세트 메뉴로!

단순히 버거 하나만 팔던 가게가, **피자(Pizza)** 까지 함께 파는 **세트 메뉴** 전문점으로 확장하면서 발생하는 문제를 살펴봅시다.

#### 1단계는 위의 '팩토리 메서드' 입니다.

#### 2단계: 문제 발생 (The Problem) - if-else 지옥
"동양식(Oriental) 세트"와 "서양식(Western) 세트"를 구분해서 팔아야 합니다.
메뉴가 늘어날수록 `if-else` 분기문이 감당할 수 없을 정도로 복잡해집니다.

```java
// 문제점: 관련된 제품군(버거+피자)을 생성하는데, 일일이 짝을 맞춰줘야 함.
class BadSetMenuFactory {
    public void createSet(String style) {
        Burger burger;
        Pizza pizza;

        // "동양식"이면 불고기버거 + 불고기피자 (직접 짝 맞춤)
        if (style.equals("Oriental")) {
            burger = new BulgogiBurger();
            pizza = new BulgogiPizza();
        } 
        // "서양식"이면 치즈버거 + 페퍼로니피자 (직접 짝 맞춤)
        else if (style.equals("Western")) {
            burger = new CheeseBurger();
            pizza = new PepperoniPizza();
        } 
        
        // 실수 발생 가능!: 나중에 코드를 수정하다가 실수로 
        // "Western"에 BulgogiPizza를 넣어버리면 '끔찍한 혼종 세트'가 탄생함.
        // 컴파일러는 이 실수를 잡아주지 못함.
        
        burger.eat();
        pizza.bake();
    }
}
```

#### 3단계: 추상 팩토리 (Abstract Factory) - 해결책
스타일별로 공장을 아예 분리합니다. 각 공장은 **"자신만의 생태계(제품군)"**를 책임지고 생산합니다.
이제 클라이언트는 `OrientalFactory`만 쓰면, 거기서 나오는 건 무조건 `Bulgogi` 세트임이 보장됩니다. 실수로 섞일 일이 없습니다.

```java
// 1. 공통 인터페이스 (세트 메뉴 공장)
interface FoodFactory {
    Burger createBurger();
    Pizza createPizza();
}

// 2. 동양식 전용 공장
// -> 여기서는 무조건 불고기 제품군만 나옴. 섞일 위험 0%
class OrientalFoodFactory implements FoodFactory {
    public Burger createBurger() { return new BulgogiBurger(); }
    public Pizza createPizza() { return new BulgogiPizza(); }
}

// 3. 서양식 전용 공장
class WesternFoodFactory implements FoodFactory {
    public Burger createBurger() { return new CheeseBurger(); }
    public Pizza createPizza() { return new PepperoniPizza(); }
}
```

---

### 2) 추상 팩토리 (Abstract Factory)
- **정의 (Definition)**: 구체적인 클래스(Concrete Class)에 의존하지 않고, 서로 연관되거나 의존적인 객체들의 **제품군(Family)** 을 생성하는 **인터페이스(Interface)를 제공**하는 패턴입니다. 구체적인 구현 내용은 **추상화(Abstraction)** 하여 감추고, 객체 생성의 책임을 별도의 팩토리 객체로 위임하여 **캡슐화(Encapsulation)** 합니다.
- **핵심 목표**: 관련성 있는 객체 집합을 일관성 있게 생성하는 것.
- **현실 비유**: 
    - **동양식(Oriental) 식당**: 불고기 버거 + 불고기 피자 (동양적 재료 통일)
    - **서양식(Western) 식당**: 치즈 버거 + 페퍼로니 피자 (서양적 재료 통일)
    - *동양식 식당에서 치즈 버거가 나오거나, 서양식 식당에서 불고기 피자가 나오는 '혼종(Mismatch)' 실수를 방지합니다.*

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={require('@site/static/img/abstract_factory_burger_uml.png').default} 
    alt="추상 팩토리 패턴 구조도 (버거 세트 예시)" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**패턴 구성 요소 (Roles)**
1. **AbstractFactory (추상 팩토리)**: 최상위 공장 인터페이스입니다. 제품군을 생성하기 위한 메서드들의 원형을 정의합니다. (예: `createButton()`, `createCheckbox()`)
2. **ConcreteFactory (구체적 팩토리)**: 추상 팩토리를 실제로 구현한 클래스입니다. 특정 변형(Variant)에 해당하는 구체적인 제품 객체들을 생성합니다. (예: `WinFactory`, `MacFactory`)
3. **AbstractProduct (추상 제품)**: 생성될 제품들의 공통 인터페이스입니다. (예: `Button`, `Checkbox`)
4. **ConcreteProduct (구체적 제품)**: 팩토리가 생성할 실제 객체입니다. (예: `WinButton`, `MacButton`)

**SOLID 원칙과의 연관성 (면접 포인트)**
- **DIP (의존 역전 원칙) 달성**: 클라이언트 코드는 구체적인 클래스(`WinFactory`, `WinButton`)가 아닌 추상적인 인터페이스(`GUIFactory`, `Button`)에 의존합니다. 이로 인해 결합도가 획기적으로 낮아집니다.
- **OCP (개방-폐쇄 원칙) 준수**: 새로운 테마(예: `Linux` 테마)를 추가해야 할 때, 기존 클라이언트 코드를 수정할 필요 없이 새로운 `LinuxFactory`와 관련 제품 클래스들만 확장(추가)하면 됩니다.

**실무적 한계 (Trade-off)**
- **새로운 '종류'의 제품 추가 시 경직성**: 이미 정의된 제품군(버거, 피자) 외에 **새로운 종류의 제품(예: 음료수)**을 세트 메뉴에 추가하려면, 최상위 인터페이스인 `FoodFactory`를 수정해야 합니다. 이는 이를 구현한 **모든 구체적 팩토리 클래스(동양식, 서양식 등)의 수정**을 유발하게 됩니다. 따라서 초기에 제품군의 범위를 신중하게 설계해야 합니다.

**📌 예시 코드 (Java) - 추상 팩토리 (세트 메뉴)**
```java
// --- 1. 제품군 인터페이스 ---
interface Burger { void eat(); }
interface Pizza { void bake(); }

// 구체적 제품들 (동양식/서양식)
class BulgogiBurger implements Burger { public void eat() { System.out.println("불고기버거 냠냠"); } }
class BulgogiPizza implements Pizza { public void bake() { System.out.println("불고기피자 굽는 중"); } }

class CheeseBurger implements Burger { public void eat() { System.out.println("치즈버거 냠냠"); } }
class PepperoniPizza implements Pizza { public void bake() { System.out.println("페퍼로니피자 굽는 중"); } }

// --- 2. 추상 팩토리 (세트 메뉴판 역할) ---
// 여기서 핵심은 '관련된 제품들'을 모두 생성할 수 있는 메서드를 정의하는 것입니다.
interface FoodFactory {
    Burger createBurger();
    Pizza createPizza();
}

// --- 3. 구체적인 팩토리 (실제 주방) ---
// 동양식 식당은 동양식 버거와 피자를 세트로 만듭니다.
class OrientalFoodFactory implements FoodFactory {
    public Burger createBurger() { return new BulgogiBurger(); }
    public Pizza createPizza() { return new BulgogiPizza(); }
}

// 서양식 식당은 서양식 버거와 피자를 세트로 만듭니다.
class WesternFoodFactory implements FoodFactory {
    public Burger createBurger() { return new CheeseBurger(); }
    public Pizza createPizza() { return new PepperoniPizza(); }
}

// --- 4. 사용 (Client) ---
class FoodStore {
    private Burger burger;
    private Pizza pizza;

    // 생성자를 통해 팩토리(의존성)를 주입받음 -> DIP 준수!
    // 어떤 팩토리(동양/서양)가 들어오든 코드는 변하지 않음 -> OCP 준수!
    public FoodStore(FoodFactory factory) {
        this.burger = factory.createBurger();
        this.pizza = factory.createPizza();
    }

    public void serve() {
        burger.eat();
        pizza.bake();
    }
}
```


---

#### [심화] 팩토리 메서드 vs 추상 팩토리, 완벽 차이점 정리

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={require('@site/static/img/burger_factory_comparison.png').default} 
    alt="버거 예시로 보는 팩토리 메서드 vs 추상 팩토리 비교 UML" 
    style={{ 
      maxWidth: '800px', 
      width: '100%', 
      borderRadius: '10px', 
      boxShadow: '0 5px 15px rgba(0,0,0,0.1)'
    }} 
  />
</div>

정보처리기사 시험과 면접에서는 **"상속(Factory Method) vs 합성(Abstract Factory)"** 과 **"단일 객체 vs 객체 군(Family)"** 이라는 키워드가 핵심입니다.

| 비교 항목 | 팩토리 메서드 (Factory Method) | 추상 팩토리 (Abstract Factory) |
| :--- | :--- | :--- |
| **추상화 수준** | **메서드 수준** (객체 하나 생성) | **클래스 수준** (연관 객체 집합 생성) |
| **핵심 키워드/구현방신** | **상속 (Inheritance)**<br/>("자식 클래스야, 네가 결정해") | **합성 (Composition)**<br/>("전용 공장 객체를 끼워줄게") |
| **생성 대상** | **단일 제품** (Single Product)<br/>(예: `Burger` 하나) | **제품군** (Product Family)<br/>(예: `Burger` + `Pizza` + `Drink` 세트) |
| **강점** | 객체 생성 로직의 분리 및 확장 용이 | 제품들 간의 **일관성(Consistency)** 보장 |
| **관점** | "어떤 객체를 만들지는 자식이 결정해!" | "관련된 부품들을 묶어서 한 번에 만들어줘!" |

> **한 줄 요약**
> - **팩토리 메서드**: "나(자식)는 어떤 버거를 만들지 결정해"
> - **추상 팩토리**: "우리는 어떤 브랜드(동양/서양)의 **세트 메뉴를 통째로** 제공할지 결정해"

**Tip**: 추상 팩토리 패턴의 내부 구현을 보면, 각 제품을 생성하는 메서드들은 종종 **팩토리 메서드 패턴**으로 구현됩니다. (즉, 추상 팩토리가 팩토리 메서드를 포함하는 형태)

---

### 3) 빌더 (Builder)

#### 1. 개요 (Introduction)
**빌더 패턴**은 복잡한 객체의 생성 과정과 표현 방법을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 **생성(Creational) 패턴**입니다.
* **핵심 키워드**: 가독성, 메서드 체이닝, 불변 객체, 생성자 오버로딩 방지.

#### 2. 빌더 패턴이 필요한 이유 (Problem)
객체 생성 시 매개변수가 많아지면 다음과 같은 문제가 발생합니다.
1. **점진적 생성자 패턴(Telescoping Constructor)**: 매개변수 개수마다 생성자를 만들어야 함.
2. **자바 빈즈 패턴(Java Beans Pattern)**: `setter`를 사용하면 객체가 생성되는 도중 설정이 변경될 수 있어 **일관성**과 **불변성**이 깨짐.

#### 3. 구조와 UML (Structure)
빌더 패턴은 크게 **Builder, ConcreteBuilder, Product, Director** 네 가지 요소로 구성됩니다.
* **Product**: 우리가 최종적으로 만들 복잡한 객체.
* **Builder**: 객체 생성 단계들을 정의하는 추상 인터페이스.
* **ConcreteBuilder**: Builder의 명세를 구현하며, 실제 부품을 조립하고 결과를 반환.
* **Director**: Builder를 사용하여 어떤 순서로 객체를 만들지 정의 (선택 사항).

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BuilderCarConceptKrImg} 
    alt="빌더 패턴 자동차 생산 공정 예시" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 4. 예시 코드 (Java)
이해하기 쉬운 **자동차(Car)** 모델링 예시입니다.

##### **Product & Builder 구현**

```java
public class Car {
    private final String engine; // 필수
    private final int wheel;     // 필수
    private final String color;  // 선택
    private final boolean sunRoof; // 선택

    // 1. Private 생성자로 외부 생성을 막고 빌더를 통해서만 생성하게 함
    private Car(Builder builder) {
        this.engine = builder.engine;
        this.wheel = builder.wheel;
        this.color = builder.color;
        this.sunRoof = builder.sunRoof;
    }

    // 2. 내부 정적 클래스로 빌더 구현
    public static class Builder {
        private String engine;
        private int wheel;
        private String color = "White"; // 기본값 설정 가능
        private boolean sunRoof = false;

        // 필수 인자는 빌더 생성자로 받음
        public Builder(String engine, int wheel) {
            this.engine = engine;
            this.wheel = wheel;
        }

        // 선택 인자는 메서드 체이닝 방식으로 구현
        public Builder setColor(String color) {
            this.color = color;
            return this;
        }

        public Builder setSunRoof(boolean sunRoof) {
            this.sunRoof = sunRoof;
            return this;
        }

        // 최종 객체를 반환하는 build 메서드
        public Car build() {
            return new Car(this);
        }
    }
}
```

##### **Client 사용 예시**

```java
// 필요한 옵션만 골라서 가독성 좋게 생성 가능
Car myCar = new Car.Builder("V8", 4)
                .setColor("Black")
                .setSunRoof(true)
                .build();
```

#### 5. 면접 대비 장단점 요약 (Pros & Cons)

| 장점 (Advantages) | 단점 (Disadvantages) |
| --- | --- |
| **가독성**: 인자가 무엇인지 명확히 알 수 있음. | **코드량**: 별도의 빌더 클래스 작성이 필요함. |
| **유연성**: 필요한 데이터만 설정 가능. | **설계 복잡도**: 단순한 객체에는 과함. |
| **불변성**: 객체 생성 후 수정이 불가능하게 설계 가능. | **성능**: 빌더 객체를 거쳐야 하므로 오버헤드 발생. |

#### 6. 정보처리기사 핵심 체크
* **분류**: 생성 패턴 (Creational Pattern)
* **특징**: 복잡한 인스턴스를 조립하여 만드는 구조. '생성'과 '표현'의 분리.
* **유사 패턴**: 추상 팩토리(Abstract Factory)와 비슷하지만, 빌더는 **단계별 생성**에 더 집중함.

#### 7. [심화] 빌더 패턴의 확장: 디렉터(Director)

##### 1) 디렉터(Director)란?
빌더가 객체를 만드는 **'방법'** 을 정의한다면, 디렉터는 객체를 만드는 **'순서와 레시피'** 를 정의합니다. 클라이언트는 빌더를 직접 조작하는 대신, 디렉터에게 특정 모델을 만들어달라고 요청하기만 하면 됩니다.

##### 2) 구조도 (UML)
빌더 패턴의 표준 UML은 다음과 같습니다. 여기서 디렉터와 빌더의 관계를 주목하세요.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BuilderDirectorUmlKrImg} 
    alt="빌더 패턴 구조도 (Director 포함) - Car 예제" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

##### 3) 디렉터를 포함한 확장 코드
기존 `Car` 예제에 디렉터를 도입하여 **"스포츠카"** 와 **"SUV"** 라는 표준 레시피를 만들어 보겠습니다.

```java
// 1. Director: 빌더를 이용해 표준화된 조립 공정을 관리
public class CarDirector {
    private Car.Builder builder;

    public CarDirector(Car.Builder builder) {
        this.builder = builder;
    }

    // 스포츠카 조립 레시피
    public void makeSportsCar() {
        builder.setEngine("V12 Turbo")
               .setWheels(4)
               .setColor("Red")
               .setSunRoof(true);
    }

    // 저가형 SUV 조립 레시피
    public void makeBasicSUV() {
        builder.setEngine("L4")
               .setWheels(4)
               .setColor("White")
               .setSunRoof(false);
    }
}

// 2. 사용 (Client)
Car.Builder builder = new Car.Builder(); // 일꾼 생성
CarDirector director = new CarDirector(builder); // 매니저에게 일꾼 전달

director.makeSportsCar(); // 매니저가 일꾼에게 스포츠카 조립 지시
Car myFerrari = builder.build(); // 완성품 수령
```

##### 4) 왜 디렉터를 써야 할까? (면접/블로그용 답변)
1. **캡슐화**: 클라이언트는 객체의 구체적인 조립 과정을 몰라도 됩니다. 오직 `makeSportsCar()` 같은 메서드만 호출하면 됩니다.
2. **재사용성**: 동일한 조립 로직(레시피)을 여러 곳에서 재사용할 수 있습니다.
3. **다양한 빌더 지원**: 만약 `CarBuilder`와 `TruckBuilder`가 같은 인터페이스를 상속받았다면, 디렉터 하나로 자동차도 만들고 트럭도 만들 수 있는 구조로 확장됩니다.

> "단순히 인자가 많아서 빌더를 쓴다"는 것은 실무적인 관점(Lombok 스타일)이고, **"객체 생성 공정을 분리하여 동일한 절차로 다양한 객체를 만든다"** 는 설명과 함께 디렉터 예시를 넣는 것이 **디자인 패턴의 본래 목적**에 더 부합합니다.

### 4) 프로토타입 (Prototype)

#### 1. 개요 (Introduction)
**프로토타입 패턴**은 미리 만들어진 객체(원형, Prototype)를 **복제(Clone)** 하여 새로운 객체를 생성하는 패턴입니다. 
- **핵심**: `new` 키워드로 객체를 처음부터 생성하는 비용이 클 때(예: DB 접근, 복잡한 계산 등), 이미 만들어진 객체를 메모리 상에서 그대로 베껴오는 것이 훨씬 효율적입니다.

#### 2. 프로토타입 레지스트리 (Prototype Registry)
단순히 `clone()`만 쓰는 것을 넘어, 자주 사용하는 객체들을 미리 만들어 등록해두고 필요할 때마다 꺼내 쓰는 **'프로토타입 레지스트리'** 방식이 실무에서 자주 사용됩니다.
- 마치 붕어빵을 미리 구워놓고 보온 진열장(Registry)에 넣어둔 뒤, 손님이 오면 바로 꺼내주는 것과 같습니다.
- **장점**: 복잡한 초기화 과정을 매번 겪지 않아도 되며, 클라이언트는 객체의 구체적인 클래스를 몰라도 레지스트리에 요청만 하면 됩니다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={PrototypePatternImg} 
    alt="프로토타입 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 3. 예시 코드 (Java) - 레지스트리 적용
다양한 색상의 `Car` 객체를 미리 등록해두고 복제해서 쓰는 예제입니다.

```java
import java.util.HashMap;
import java.util.Map;

// 1. 프로토타입 인터페이스
interface Prototype {
    Prototype clone();
}

// 2. 구체적인 클래스
class Car implements Prototype {
    private String color;
    
    public Car(String color) { 
        this.color = color; 
        // 가정: 여기서 매우 비싼 초기화 작업이 발생함 (예: 데이터 로딩 2초)
    }
    
    // 복사 생성자 (깊은 복사 등을 처리하기 위함)
    public Car(Car source) { 
        this.color = source.color; 
    } 

    @Override
    public Prototype clone() { 
        return new Car(this); // 나 자신을 기반으로 새 객체 생성
    }

    @Override
    public String toString() { return color + " car"; }
}

// 3. 프로토타입 레지스트리 (객체 보관소)
class BundledShapeRegistry {
    private Map<String, Prototype> cache = new HashMap<>();

    public BundledShapeRegistry() {
        // 미리 기본 아이템들을 생성해서 등록 (Expensive Operation)
        Car redCar = new Car("Red");
        Car blueCar = new Car("Blue");
        
        addItem("Red_Sport_Car", redCar);
        addItem("Blue_Family_Car", blueCar);
    }

    public void addItem(String id, Prototype p) {
        cache.put(id, p);
    }

    public Prototype getById(String id) {
        if (!cache.containsKey(id)) return null;
        // 핵심: 원본을 그대로 주지 않고, 반드시 '복제본'을 반환함
        return cache.get(id).clone();
    }
}

// 4. 사용 (Client)
public class Main {
    public static void main(String[] args) {
        BundledShapeRegistry registry = new BundledShapeRegistry();

        // 손님: "빨간 스포츠카 하나 주세요"
        // -> 새로 조립하는 게 아니라, 이미 있는 걸 복제해서 줌 (엄청 빠름)
        Car myCar1 = (Car) registry.getById("Red_Sport_Car");
        System.out.println("출고 1: " + myCar1);

        Car myCar2 = (Car) registry.getById("Red_Sport_Car");
        // myCar1과 myCar2는 내용은 같지만 서로 다른 객체임!
    }
}
```

#### 4. [심화] 얕은 복사 vs 깊은 복사 (면접 단골 질문)
프로토타입 패턴 구현 시 가장 조심해야 할 부분입니다.

1. **얕은 복사 (Shallow Copy)**:
   - 객체의 주소값만 복사합니다. 
   - **문제점**: 원본 객체가 참조하고 있는 내부 객체(예: 배열, 리스트)가 있다면, 복제본도 **같은 내부 객체**를 공유하게 됩니다. 복제본을 수정했는데 원본이 같이 바뀌는 대참사가 일어납니다.
   - 자바의 `Object.clone()` 기본 동작은 얕은 복사입니다.

2. **깊은 복사 (Deep Copy)**:
   - 객체 내부의 참조 객체까지 모두 새로 생성해서 복사합니다.
   - **해결책**: 위 예제처럼 **복사 생성자**를 직접 구현하여 내부 필드 값을 일일이 새로 할당해주는 것이 안전합니다.

#### 5. 정보처리기사 핵심 요약
- **분류**: 생성 패턴 (Creational Pattern)
- **키워드**: `clone`, `복제`, `프로토타입 레지스트리`, `얕은 복사/깊은 복사`
- **언제 쓰는가?**: 클래스 종류가 너무 많거나, 객체 초기화 비용(DB연결, 통신 등)이 매우 비쌀 때.

### 5) 싱글톤 (Singleton)

#### 1. 개념

* **정의**: 클래스의 **인스턴스를 오직 하나만 생성**하도록 제한하고, 그 인스턴스에 전역적으로 접근할 수 있는 지점을 제공하는 패턴입니다.
* **목적**: 동일한 자원(DB 커넥션, 설정 정보 등)을 사용하는 객체를 여러 개 만들지 않고 **메모리 낭비를 방지**하며, 데이터의 **일관성**을 유지하기 위해 사용합니다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={SingletonPatternImg} 
    alt="싱글톤 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 2. 순수 Java에서의 구현 (멀티스레드 고려)

단순히 `if (instance == null)`로 구현하면 멀티스레드 환경에서 인스턴스가 2개 생길 수 있는 **Race Condition**이 발생합니다. 이를 방지하기 위한 정석 코드는 다음과 같습니다.

##### Double-Checked Locking (DCL) 방식

```java
public class Singleton {
    // volatile: 캐시가 아닌 메인 메모리에서 값을 읽도록 보장 (가시성 해결)
    private static volatile Singleton instance;

    private Singleton() { } // private 생성자로 외부 생성 차단

    public static Singleton getInstance() {
        Singleton result = instance; // 로컬 변수 활용으로 성능 최적화
        if (result == null) {
            synchronized (Singleton.class) { // 필요한 순간에만 동기화 (성능 저하 방지)
                result = instance;
                if (result == null) {
                    instance = result = new Singleton();
                }
            }
        }
        return result;
    }
}
```

#### 3. Spring Boot 환경에서의 싱글톤

Spring 프레임워크는 사용자가 직접 위와 같은 복잡한 코드를 짜지 않아도 되도록 **'싱글톤 컨테이너'** 역할을 수행합니다.

* **특징**: `@Service`, `@Repository`, `@RestController` 등으로 등록된 빈(Bean)은 스프링 컨테이너가 시작될 때 **기본적으로 싱글톤으로 생성**됩니다.
* **주의사항 (중요)**: 싱글톤 객체는 여러 스레드가 공유하므로, **상태를 유지(Stateful)하게 설계하면 안 됩니다.** 반드시 **무상태(Stateless)** 로 설계해야 합니다.

##### 실무형 코드 (안전한 설계)

```java
@Service
public class WorkService {
    // 1. 다른 서비스나 리포지토리는 final로 선언하여 변경 방지 (Thread-safe)
    private final WorkRepository workRepository;

    public WorkService(WorkRepository workRepository) {
        this.workRepository = workRepository;
    }

    public void doWork(String memberName) {
        // 2. 공유 필드 변수 대신 '로컬 변수'를 사용하여 개별 스레드 독립성 보장
        String logMessage = memberName + " 작업 시작"; 
        workRepository.save(logMessage);
    }
}
```

#### 4. [심화] Spring 싱글톤 빈의 원자성·무결성 보존 방법

스프링의 `@Service`나 `@Component`는 싱글톤이므로, 여러 스레드가 동시에 필드 변수에 접근할 때 데이터가 꼬이는 '동시성 문제'가 발생합니다. 이를 해결하는 3가지 방법입니다.

##### 1. 무상태(Stateless) 설계 (가장 권장됨)

가장 좋은 방법은 **필드 변수에 공유 데이터를 두지 않는 것** 입니다. 데이터를 필드 대신 **메서드의 파라미터나 로컬 변수** 로 전달합니다. 로컬 변수는 스레드마다 독립적인 스택(Stack) 영역에 할당되므로 절대 꼬이지 않습니다.

```java
@Service
public class OrderService {
    // 위험: 공유 필드 (여러 사용자가 동시에 접근하면 데이터 오염)
    // private int totalCount; 

    public void processOrder(String itemName) {
        // 안전: 로컬 변수 (각 스레드마다 별도로 생성됨)
        int currentCount = 1; 
        System.out.println(itemName + " 처리 중...");
    }
}
```

##### 2. 원자적 객체(Atomic Type) 사용

꼭 공유되는 숫자를 세거나 값을 바꿔야 한다면, `int`나 `long` 대신 자바의 **Atomic 클래스**를 사용합니다. 이 클래스들은 내부적으로 **CAS(Compare-And-Swap)** 알고리즘을 사용하여 별도의 `synchronized` 없이도 원자성을 보장합니다.

```java
@Service
public class CounterService {
    // 원자성 보장: 여러 스레드가 동시에 증가시켜도 정확한 값을 유지함
    private final AtomicInteger visitorCount = new AtomicInteger(0);

    public void addVisitor() {
        visitorCount.incrementAndGet(); // 원자적 증가
    }
}
```

##### 3. ThreadLocal 사용

사용자 인증 정보나 트랜잭션 번호처럼, **"스레드별로 독립적인 상태"** 를 유지해야 할 때 사용합니다. 싱글톤 객체 안에서도 각 스레드만의 전용 보관함을 가질 수 있게 해줍니다.

```java
@Service
public class UserContextService {
    // 각 스레드(사용자)마다 별개의 저장 공간을 할당함
    private static final ThreadLocal<String> currentUser = new ThreadLocal<>();

    public void login(String userId) {
        currentUser.set(userId);
    }

    public String getUserId() {
        return currentUser.get();
    }
}
```

##### 4. 보존 방법 핵심 요약

| 방법 | 원리 | 적용 상황 |
| --- | --- | --- |
| **무상태(Stateless)** | 로컬 변수(Stack) 활용 | 일반적인 비즈니스 로직 처리 시 (필수 원칙) |
| **Atomic 클래스** | 하드웨어 레벨의 원자적 연산 | 전역 카운터, 공유 수치 계산 시 |
| **ThreadLocal** | 스레드 전용 보관함 생성 | 사용자 세션 정보, 트랜잭션 컨텍스트 유지 시 |

**면접용 멘트**

> "Spring의 싱글톤 빈은 여러 스레드가 공유하기 때문에 **무상태(Stateless)** 로 설계하는 것이 원칙입니다. 만약 공유 자원의 **원자성**을 보존해야 한다면 `AtomicInteger` 같은 원자적 객체를 사용하거나, 스레드별 독립 공간이 필요할 경우 `ThreadLocal`을 사용하여 데이터 **무결성** 을 보장합니다."

#### 5. 요약: 정보처리기사 & 면접 핵심 포인트

| 구분 | 주요 내용 |
| --- | --- |
| **핵심 장점** | 메모리 효율성, 데이터 공유, 인스턴스 개수 제한 보장. |
| **핵심 단점** | 결합도가 높아짐(TDD가 어려움), 멀티스레드 환경에서 동기화 처리 필요. |
| **volatile** | CPU 캐시가 아닌 메인 메모리에 직접 접근하게 하여 스레드 간 데이터 불일치 해결. |
| **Stateless** | 싱글톤 객체 내부에 수정 가능한 필드 변수를 두지 않는 설계 원칙 (멀티스레드 안전). |

**면접 예상 질문 대비**

* **Q: 싱글톤 패턴에서 `volatile` 키워드가 왜 필요한가요?**
* **A:** 멀티스레드 환경에서 인스턴스가 생성되는 도중 다른 스레드가 '미완성된 객체'를 참조하는 것을 막고, 메인 메모리에서의 데이터 가시성을 보장하기 위해 필요합니다.


* **Q: 스프링 빈은 왜 싱글톤인가요?**
* **A:** 매번 요청마다 객체를 새로 생성하면 메모리 부하가 심해지기 때문입니다. 대신 효율적인 공유를 위해 싱글톤으로 관리하며, 개발자는 무상태(Stateless) 설계를 준수해야 합니다.
---

#### [면접 대비] 생성 패턴 5대장 한눈에 비교하기

| 패턴 이름 | 핵심 키워드 | 언제 쓰나요? (실무/비유) | 특징 및 차이점 |
| :--- | :--- | :--- | :--- |
| **추상 팩토리**<br/>(Abstract Factory) | **관련 객체 군집** | **"테마 변경"** (윈도우/맥 테마에 따라 버튼, 창, 스크롤바가 세트로 바뀔 때) | 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관된 객체들의 집합을 생성. |
| **팩토리 메서드**<br/>(Factory Method) | **상속 & 오버라이딩** | **"프레임워크"** (스프링 프레임워크가 빈(Bean)을 생성할 때, 구체적인 생성은 하위 클래스에 위임) | 객체 생성 처리를 서브 클래스로 분리하여 캡슐화. (가상 생성자) |
| **빌더**<br/>(Builder) | **복잡한 단계** | **"수제 버거 주문", "여행 패키지"** (재료가 많고 순서가 복잡할 때 단계별로 조립) | 복잡한 인스턴스를 조립하여 만듦. 생성 과정과 표현 방법을 분리. |
| **프로토타입**<br/>(Prototype) | **복제 (Clone)** | **"게임 몬스터 소환"** (기본 몬스터 하나 만들어두고 계속 복제해서 떼거지로 생성) | 원본 객체를 복제하여 새 객체를 생성 (`clone`). 비용이 큰 객체 생성 시 유리. |
| **싱글톤**<br/>(Singleton) | **유일한 인스턴스** | **"프린터 스풀러 / DB 커넥션 풀"** (전 시스템에서 딱 하나만 있어야 하는 관리자) | 전역에서 접근 가능한 유일한 객체를 보장. 메모리 낭비 방지. |

---

### 2. 구조 패턴 (Structural Patterns)
- **개념**: 클래스나 객체를 조합하여 **더 큰 구조**를 만드는 패턴. 서로 다른 인터페이스를 가진 객체들을 묶어서 새로운 기능을 제공하거나 인터페이스를 통일함.
- **핵심 패턴 7가지**: **어댑터, 데코레이터, 파사드, 브리지, 컴포지트, 플라이웨이트, 프록시**

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={StructuralPatternsImg} 
    alt="구조 패턴 핵심 아이콘" 
    style={{ 
      maxWidth: '800px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 1) 어댑터 (Adapter)

#### 1. 개념 (Concept)

**어댑터 패턴(Adapter Pattern)**은 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 **적응(Adapt)** 시키는 패턴입니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들이 함께 작동하도록 중간에서 **변환기** 역할을 합니다.

* **GoF 디자인 패턴 분류:** 구조 패턴 (Structural Pattern)
* **핵심 목적:** 인터페이스 불일치 해결, 코드 재사용성 증대

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={AdapterPatternImg} 
    alt="어댑터 패턴 구조도 (기존)" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 2. UML 다이어그램 (Structure)

어댑터 패턴의 구조는 크게 4가지 요소로 구성됩니다.

1. **Target (인터페이스):** 클라이언트가 직접적으로 사용하길 원하는 표준 인터페이스 (예: `Plug220V`)
2. **Client (사용자):** Target 인터페이스를 통해 기술을 사용하는 주체
3. **Adaptee (개조 대상):** 아직 호환되지 않는 기존의 클래스 (예: `Plug110V`)
4. **Adapter (어댑터):** Adaptee를 Target 인터페이스에 맞게 감싸는(Wrap) 클래스

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={require('@site/static/img/adapter_pattern_uml_detailed.png').default} 
    alt="어댑터 패턴 UML 클래스 다이어그램" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 3. 예시 코드 (Java)

```java
// [Adaptee] : 이미 존재하지만 형식이 다른 서비스 (수정 불가)
class OldXmlSystem {
    public void processXml(String xmlData) {
        System.out.println("XML 데이터 처리 중: " + xmlData);
    }
}

// [Target] : 클라이언트가 사용하고자 하는 현대적인 인터페이스
interface JsonService {
    void processJson(String jsonData);
}

// [Adapter] : XML 시스템을 JSON 서비스 규격에 맞게 변환
class XmlToJsonAdapter implements JsonService {
    private final OldXmlSystem oldSystem;

    public XmlToJsonAdapter(OldXmlSystem oldSystem) {
        this.oldSystem = oldSystem;
    }

    @Override
    public void processJson(String jsonData) {
        // 1. JSON을 XML로 변환하는 로직 (통역사 역할)
        String convertedXml = convertJsonToXml(jsonData);
        
        // 2. 변환된 데이터를 기존 시스템에 전달
        oldSystem.processXml(convertedXml);
    }

    private String convertJsonToXml(String json) {
        return "<xml>" + json + "</xml>"; // 단순 변환 예시
    }
}

// [Client] : 실제 사용 부분
public class Main {
    public static void main(String[] args) {
        // 기존 시스템을 어댑터에 넣어서 JSON 서비스처럼 사용
        OldXmlSystem legacySystem = new OldXmlSystem();
        JsonService service = new XmlToJsonAdapter(legacySystem);
        
        service.processJson("{ \"name\": \"Gemini\" }");
    }
}
```

#### 4. 면접 대비 핵심 포인트 (Interview & Exam)

**Q. 어댑터 패턴을 왜 사용하나요?**

1. **기존 코드의 재사용:** 검증된 기존 클래스(Legacy)를 수정하지 않고 그대로 활용할 수 있습니다.
2. **OCP(개방-폐쇄 원칙) 준수:** 기존 코드를 변경하지 않으면서(Closed), 어댑터를 통해 새로운 기능을 확장(Open)할 수 있습니다.
3. **결합도 감소:** 클라이언트는 어댑터 뒤에 숨겨진 실제 구현체(Adaptee)가 어떻게 작동하는지 몰라도 됩니다.

**Q. 어댑터 패턴의 종류 2가지는? (정보처리기사 빈출)**

* **객체 어댑터 (Object Adapter):** 합성을 사용함. (위의 예시 코드 방식) 대부분 이 방식을 권장합니다.
* **클래스 어댑터 (Class Adapter):** 다중 상속을 사용함. Java는 다중 상속을 지원하지 않으므로 사용이 제한적입니다.

**Q. '포트와 어댑터(Ports and Adapters)'와 GoF의 '어댑터 패턴'은 같은 건가요?**

* **어댑터 패턴:** 클래스 간의 인터페이스 변환을 다루는 **디자인 패턴**입니다.
* **포트와 어댑터:** 비즈니스 로직을 외부 환경(DB, UI)으로부터 분리하는 **아키텍처 패턴(헥사고날 아키텍처)** 입니다. 포트와 어댑터 아키텍처를 구현할 때 내부적으로 GoF의 어댑터 패턴 원리를 사용합니다.

**기술 블로그 팁**

> "어댑터 패턴은 단순히 코드를 연결하는 것을 넘어, **서드파티 라이브러리 업데이트** 나 **데이터베이스 교체** 시 내 비즈니스 로직을 보호하는 방어막 역할을 합니다."

### 2) 데코레이터 (Decorator)
- **개념**: 객체의 결합을 통해 **기능을 동적으로 유연하게 확장**할 수 있게 해주는 패턴.
- **비유**: **커피(기본) + 우유 추가(라떼) + 시럽 추가(바닐라 라떼)**
- **특징**: 상속(Inheritance)보다 유연하게 기능을 확장할 수 있다. (러시아 인형 마트료시카처럼 계속 감싸는 구조)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={DecoratorPatternImg} 
    alt="데코레이터 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**예시 코드 (Java)**
```java
// 1. 기본 커피
interface Coffee { String brew(); }
class PlainCoffee implements Coffee {
    public String brew() { return "커피"; }
}

// 2. 데코레이터 (토핑 추가)
class MilkDecorator implements Coffee {
    private Coffee coffee;
    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }
    
    public String brew() {
        return coffee.brew() + " + 우유"; // 기능 추가!
    }
}

// 사용
Coffee myCoffee = new PlainCoffee(); // "커피"
myCoffee = new MilkDecorator(myCoffee); // "커피 + 우유"
```

### 3) 파사드 (Facade)
- **개념**: 복잡한 서브 시스템들의 인터페이스를 통합하여, 사용하기 쉬운 **하나의 간략한 인터페이스**를 제공하는 패턴.
- **비유**: **리모컨의 '전원' 버튼** (누르면 TV, 셋탑, 스피커가 알아서 다 켜짐)
- **특징**: 클라이언트와 서브 시스템 간의 결합도를 낮춤. (복잡한 건 파사드 뒤에 숨김)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={FacadePatternImg} 
    alt="파사드 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**예시 코드 (Java)**
```java
// 복잡한 서브 시스템들
class CPU { void freeze() {} void jump() {} }
class Memory { void load() {} }
class HardDrive { void read() {} }

// 파사드 (단순화된 인터페이스)
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hdd;
    public ComputerFacade() { /* 생성 */ }

    // 복잡한 부팅 과정을 메서드 하나로 퉁칩니다.
    public void startComputer() {
        cpu.freeze();
        memory.load();
        hdd.read();
        cpu.jump();
        System.out.println("컴퓨터 부팅 완료!");
    }
}
```

### 4) 브리지 (Bridge)
- **개념**: **구현부와 추상층을 분리**하여 독자적으로 확장할 수 있게 하는 패턴.
- **특징**: 기능 클래스 계층과 구현 클래스 계층을 연결(Bridge)한다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BridgePatternImg} 
    alt="브리지 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**예시 코드 (Java)**
```java
// 구현부: 색상
interface Color { void applyColor(); }
class Red implements Color { public void applyColor() { System.out.println("빨강"); } }

// 추상부: 모양
abstract class Shape {
    protected Color color;
    public Shape(Color c) { this.color = c; } // Bridge 연결
    abstract void draw();
}
class Circle extends Shape {
    public Circle(Color c) { super(c); }
    public void draw() { 
        System.out.print("원 그리기: "); 
        color.applyColor(); 
    }
}
```

### 5) 컴포지트 (Composite)
- **개념**: 부분과 전체를 동일하게 취급하여 **트리 구조**로 구성하는 패턴.
- **비유**: **파일 탐색기 (폴더 = 파일들의 집합)**
- **특징**: 단일 객체와 복합 객체를 구분 없이 다룰 수 있음.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={CompositePatternImg} 
    alt="컴포지트 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 6) 플라이웨이트 (Flyweight)
- **개념**: 인스턴스를 가능한 한 **공유(Sharing)**하여 메모리를 절약하는 패턴.
- **특징**: 'Flyweight(가벼운급)'라는 이름처럼 가볍게 만듦. 같은 것은 공유해서 씀.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={FlyweightPatternImg} 
    alt="플라이웨이트 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

### 7) 프록시 (Proxy)
- **개념**: 실제 객체에 대한 접근을 제어하기 위해 **대리인(Proxy) 객체**를 두는 패턴.
- **특징**: 접근 제어, 지연 로딩 등에 사용됨.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={ProxyPatternImg} 
    alt="프록시 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>
