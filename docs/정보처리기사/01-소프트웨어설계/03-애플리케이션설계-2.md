---
id: 애플리케이션설계-2
---

# 애플리케이션 설계 2

import EncapsulationVsDataHidingImg from '@site/static/img/encapsulation_vs_data_hiding.png';
import GofPatternsImg from '@site/static/img/gof_design_patterns_types.png';
import AbstractFactoryImg from '@site/static/img/abstract_factory_diagram.png';
import FactoryMethodImg from '@site/static/img/factory_method_diagram.png';
import BuilderPatternImg from '@site/static/img/builder_pattern_diagram.png';
import PrototypePatternImg from '@site/static/img/prototype_pattern_diagram.png';
import SingletonPatternImg from '@site/static/img/singleton_pattern_diagram.png';

## 객체지향 설계 
### 객체(Object))와 객체지향
- 객체(Object)는 객체 데이터(속성)와 해우이(메서드)로 이루어진 것이고 객체지향은 현실 ㅔ계를 객체의 집합으로 보는 개념을 말한다.

### 객체지향 방법론
- 소프트웨어 개발 과정은 기존 시스템을 분석하고 이를 표준화된 새로운 시스템 환경으로 전환하는데 초점을 맞추게 되었다.
- 소프트웨어를 개발할 때 작은 단위의 모듈들을 구성하여 추후 이를 재사용하여 소프트웨어의 효율성을 높이자는 생각에서 객체지향 방법론이 발전하게 되었다.
- 여러 객체지향 방법론들이 난립하게 되고 표기법만이라도 통하자는 제안에 의해 UML을 사용하게 되었다. 

#### 1) 객체지향 방법론 개념
import OopConceptsImg from '@site/static/img/oop_concepts_visual.png';

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={OopConceptsImg} 
    alt="객체지향 4대 핵심 개념" 
    style={{ 
      maxWidth: '700px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>
| 용어 | 영문 | 개념 및 설명 |
|---|---|---|
| **객체** | Object | - 정보를 효율적으로 관리하기 위한 개념적인 단위<br/>- 업무 수행을 위한 대상이 되는 사람, 장소, 사물, 사건 및 개념 |
| **클래스** | Class | - 공통 속성과 행위를 가진 객체를 묶어 추상화한 개념 |
| **속성** | Property | - 객체가 가지고 있는 데이터 값 |
| **메서드** | Method | - 클래스로부터 생성된 객체를 사용하는 방법이나 연산 |
| **캡슐화** | Encapsulation | - 구현부가 외부에 노출되지 않게 감싸진 상태<br/>- 변경 시 오류 파급 효과가 적음 |
| **정보 은닉**<br/>(데이터 은닉) | Information<br/>Hiding | - 캡슐화의 결과<br/>- 다른 객체에게 자신의 내부 데이터를 숨기고, 공개된 연산(메서드)만 접근 허용 |
| **상속** | Inheritance | - 상위(부모) 클래스가 가진 속성과 행위를 하위(자식) 객체가 물려받는 것 |
| **조합** | Composition | - 다른 객체를 사용하여 새로운 객체를 구성하는 것 (조립) |
| **메시지** | Message | - 객체 간의 상호작용 수단 (객체 A가 객체 B의 메서드를 호출하는 행위) |
| **추상화** | Abstraction | - 복잡한 현실 세계를 모델링하거나 문제를 단순화하는 과정 |
| **다형성** | Polymorphism | - 같은 이름의 메서드가 상황(객체)에 따라 다르게 동작하는 성질 |

<br/>

**📌 다형성 (Polymorphism) 코드 예시**

```java
// 부모 클래스
class Animal {
    void makeSound() {
        System.out.println("동물 소리");
    }
}

// 자식 클래스들
class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("야옹~");
    }
}

// 사용
Animal myPet1 = new Dog();  // 부모 타입으로 선언
Animal myPet2 = new Cat();

myPet1.makeSound();  // "멍멍!" 출력
myPet2.makeSound();  // "야옹~" 출력

// 같은 makeSound() 메서드인데 결과가 다름!
```

캡슐화 (Encapsulation) vs 데이터 은닉 (Data Hiding)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={EncapsulationVsDataHidingImg} 
    alt="캡슐화 vs 데이터 은닉 비교" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

#### 2) SOLID (객체지향 설계 원칙)
- 로버트 마틴이 2000년대 초반에 명명한 것을 마이클 페더스가 두문자어 기억술로 소개한 것으로 객체지향 설계에서 지켜야할 5개의 소프트웨어 개발 원칙이다.

| SOLID | 약어 | 명명 | 설명 |
|----|----|---------------------------------------------|---------------------------------------------|
| S | SRP | 단일책임 원칙(Single responsibility principle) | 한 클래스는 하나의 책임(기능)만 가지도록 설계|
| O | OCP | 개방/폐쇄 원칙(Open/closed principle) | 새로운 변경 사항이 발생했을 때 쉽게 확장 가능 해야하나 객체를 직접적으로 수정하지는 못하게 해야 한다 ( 소프트웨어의 구조를 변경하지 않고 확장할 수 있도록 설계 )|
| L | LSP | 리스코프 치환 원칙(Liskov substitution principle) | 다형성과 관련, 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입으로 바꿀 수 있어야 한다. (서브 타입은 슈퍼 타입의 모든 사용에 대체할 수 있도록 설계) |
| I | ISP | 인터페이스 분리 원칙(Interface segregation principle) | 인터페이스를 각각의 목적과 용도에 적합하게 잘 분리해야 한다는 설계 원칙. 클라이언트가 필요하지 않은 인터페이스는 분리하여 설계 |
| D | DIP | 의존성 역전 원칙(Dependency inversion principle) | 구현체보다 추상화된 인터페이스에 의존하도록 설계 한다는 원칙으로 어떤 Class를 참조해서 사용해야 할 때 그 Class를 직접 참조하지 말고 그 대상의 상위 요소인 추상 클래스나 인터페이스를 참조하라는 원칙 |

### 객체지향 방법론 종류
| 기법 | 원리 |
|-----------------------------|-----------------------------|
| 럼바우 - OMT (Object-Modeling-Tecnique) 법| 객체지향 분석 절차 객체(정보)모델링(객체다이어그램) - 동적모델링(상태다이어그램) - 기능모델링 (자료흐름도)| 
| 부치 - Booch 법 | 클래스 다이어그램, 객체 다이어그램, 상태 다이어그램 등의 UML 다이어그램을 사용하여 시스템을 모델링하여 시스템의 구조와 동작을 시각적으로 표현하며 미시적 개발 프로세스와 거시적 개발 프로세 방법을 모두 사용한다.|
| 코드와 요던 - Cord/Yourdon범 | E - R 다이어그램을 사용하여 시스템의 구조와 행위를 분석하고 설계한다. |
| 슐레이어와 멜러 Shlarer/Mellor법 | 객체 지향 시스템을 구조적이고 명확하게 분석하고 설계하기 위한 방법론으로, 특히 실시간 시스템에서의 모델링에 적합하다.|
| 야콥슨 - OOSE (Object-Oriented Software  Engineering) 법 | 유스케이스(Use Case) 를 중심으로 시스템의 기능적 요구사항을 분석하고 모델링한다. |



## 디자인패턴
### 디자인 패턴의 정의 
- 반복적으로 나타나는 문제점들에 대한 해결 방안을 제시한 것
- 다양한 으용 소프트웨어 시스템들을 개발할 때 존재하는 공통되는 설계문제, 공통되는 해결책을 묶어 디자인 패턴이라고 한다.
- 팀원 사이의 의사소통을 쉽게 해준다
- UML과 같은 일종의 설계 기법이며, 설계방법이다.
- SW설계 시 SW 재사용성, 호환성, 유지보수성을 보장하여 '올바른 설계'를 빠르게 만들 수 있도록 도와준다. 

### 디자인 패턴의 구성요소
- 패턴이름 (Pattern Name) : 패턴의 이름은 해당 패턴의 솔루션을 담고 있다.
- 문제 (Problem) : 패턴이 적용되어 해결될 필요가 있는 디자인이다.
- 해결책 (Solution) : 문제를 해결하기 위한 요소들 사이의 관계, 책임, 협력관계 등으로 다양한 상황에 적용할 수 있는 템플릿과 같다.
- 결과 (Consequence) : 패턴을 적용해서 얻을 수 있는 결과와 장단점 등이다. 

### GoF 디자인 패턴 분류
- 생성 패턴 (Creational Pattern) : 객체 생성에 관련된 패턴. 간단한 블록의 코드로 여러 가지의 다양한 객체를 생성할 수 있다.
- 구조 패턴 (Structural Pattern) : 클래스나 객체의 구조를 조합해 더 큰 구조를 만드는 패턴으로 복잡한 구조의 큰 시스템을 쉽고 효율적으로 만들 수 있게 해준다.
- 행위 패턴 (Behavioral Pattern) : 반복적으로 일어나는 객체 간의 상호작용을 패턴화 해 놓은 것으로 객체들 간의 알고리즘이나 역할 분담에 관련된 것들을 정의해 놓았다.

### 디자인 패턴 유형

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={GofPatternsImg} 
    alt="GoF 디자인 패턴 3가지 유형 분류" 
    style={{ 
      maxWidth: '800px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

## Gof 디자인 패턴의 세부 종류
### 1. 생성 (Creational) 패턴 

### 1) 추상 팩토리 (Abstract Factory)
- **개념**: 관련성 있는 객체들의 조합(Family)을 생성하기 위한 인터페이스를 제공하는 패턴.
- **특징**: 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 다른 제품군(Product Family)을 생성할 수 있다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={AbstractFactoryImg} 
    alt="추상 팩토리 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**

```java
// 1. 추상 팩토리 (인터페이스)
interface ElectronicsFactory {
    Phone createPhone();
    TV createTV();
}

// 2. 구체적인 팩토리 (삼성) - 삼성 제품군 생성
class SamsungFactory implements ElectronicsFactory {
    public Phone createPhone() { return new GalaxyPhone(); }
    public TV createTV() { return new SamsungTV(); }
}

// 3. 구체적인 팩토리 (LG) - LG 제품군 생성
class LGFactory implements ElectronicsFactory {
    public Phone createPhone() { return new LGPhone(); }
    public TV createTV() { return new LGTV(); }
}

// 4. 클라이언트 (Factory만 알고 있음, 구체적인 제품 모름)
class Client {
    public void createProduct(ElectronicsFactory factory) {
        Phone phone = factory.createPhone();
        TV tv = factory.createTV();
        // ... 사용 ...
    }
}
```

### 2) 팩토리 메서드 (Factory Method)
- **개념**: 객체를 생성하기 위한 인터페이스를 정의하지만, **어떤 클래스의 인스턴스를 생성할지는 서브 클래스가 결정**하게 하는 패턴.
- **특징**: 객체 생성의 책임을 서브 클래스로 미룬다(위임한다). `Virtual Constructor`라고도 불린다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={FactoryMethodImg} 
    alt="팩토리 메서드 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**

```java
// 1. Creator (물류 회사) - 추상 클래스
abstract class Logistics {
    // 팩토리 메서드 (구현은 자식이!)
    abstract Transport createTransport();

    public void planDelivery() {
        Transport t = createTransport();
        t.deliver();
    }
}

// 2. Concrete Creator (육로 물류)
class RoadLogistics extends Logistics {
    @Override
    Transport createTransport() {
        return new Truck(); // 트럭 생성
    }
}

// 3. Concrete Creator (해상 물류)
class SeaLogistics extends Logistics {
    @Override
    Transport createTransport() {
        return new Ship(); // 배 생성
    }
}

// 4. Products (운송 수단)
interface Transport { void deliver(); }
class Truck implements Transport {
    public void deliver() { System.out.println("트럭으로 육로 배송"); }
}
class Ship implements Transport {
    public void deliver() { System.out.println("배로 해상 배송"); }
}
```

### 3) 빌더 (Builder)
- **개념**: 복잡한 인스턴스를 조립하여 만드는 구조로, **생성 과정과 표현 방법을 분리**하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴.
- **특징**: 생성 단계를 분리하여 **복잡한 객체를 단계별로 생성**할 수 있다. (햄버거 주문: 빵 -> 패티 -> 야채)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={BuilderPatternImg} 
    alt="빌더 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java) - Lombok `@Builder`가 이 원리!**
```java
// 빌더 패턴 사용
class Burger {
    private String bun;
    private String patty;
    private String sauce;

    // 생성자를 private으로 숨김
    private Burger(Builder builder) {
        this.bun = builder.bun;
        this.patty = builder.patty;
        this.sauce = builder.sauce;
    }

    // static 내부 클래스 (빌더)
    public static class Builder {
        private String bun;
        private String patty;
        private String sauce;

        public Builder bun(String bun) { this.bun = bun; return this; }
        public Builder patty(String patty) { this.patty = patty; return this; }
        public Builder sauce(String sauce) { this.sauce = sauce; return this; }

        public Burger build() { return new Burger(this); }
    }
}

// 사용 (체이닝 방식)
Burger myBurger = new Burger.Builder()
    .bun("깨빵")
    .patty("소고기")
    .sauce("바베큐")
    .build();
```

### 4) 프로토타입 (Prototype)
- **개념**: 처음부터 일반적인 원형(Prototype)을 만들어 놓고, 이를 **복사(Cloning)**하여 필요한 부분만 수정해서 사용하는 패턴.
- **특징**: 객체 생성 비용(DB 조회 등)이 높을 때, 이미 생성된 객체를 복제하여 성능을 높인다.

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={PrototypePatternImg} 
    alt="프로토타입 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java) - `Cloneable` 인터페이스**
```java
class Sheep implements Cloneable {
    private String name;

    public Sheep(String name) { this.name = name; }
    public void setName(String name) { this.name = name; }

    // 복제 메서드
    @Override
    public Sheep clone() {
        try {
            return (Sheep) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }
}

// 사용
Sheep dolly = new Sheep("Dolly");
Sheep clonedSheep = dolly.clone(); // 복제! (new Sheep() 안 함)
clonedSheep.setName("Molly"); // 이름만 변경
```

### 5) 싱글톤 (Singleton)
- **개념**: 전역 변수를 사용하지 않고 **객체를 하나만 생성**하도록 하며, 생성된 객체를 어디서든지 참조할 수 있도록 하는 패턴.
- **특징**: 메모리 낭비를 방지하고 데이터 공유가 쉽다. (환경설정, DB 연결 풀 등)

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img 
    src={SingletonPatternImg} 
    alt="싱글톤 패턴 구조도" 
    style={{ 
      maxWidth: '600px', 
      width: '100%', 
      borderRadius: '20px', 
      boxShadow: '0 10px 30px rgba(0,0,0,0.2)'
    }} 
  />
</div>

**📌 예시 코드 (Java)**
```java
class SystemConfig {
    // 1. 자기 자신의 인스턴스를 하나만 가짐 (static)
    private static SystemConfig instance;

    // 2. 생성자를 private으로 막음 (외부에서 new 금지)
    private SystemConfig() {}

    // 3. 오직 이 메서드로만 접근 가능
    public static SystemConfig getInstance() {
        if (instance == null) {
            instance = new SystemConfig();
        }
        return instance;
    }
}

// 사용
SystemConfig config1 = SystemConfig.getInstance();
SystemConfig config2 = SystemConfig.getInstance();
// config1 == config2 (같은 객체임!)
```

---

#### 💡 [면접 대비] 생성 패턴 5대장 한눈에 비교하기

| 패턴 이름 | 핵심 키워드 | 언제 쓰나요? (실무 예시) | 차이점/비고 |
|---|---|---|---|
| **추상 팩토리**<br/>(Abstract Factory) | **제품군(Family) 생성** | **OS별 테마 적용** (윈도우/맥 버튼+창 동시 생성), DB별 연결 세트 | 팩토리 메서드보다 상위 개념 (공장 자체를 추상화) |
| **팩토리 메서드**<br/>(Factory Method) | **생성 책임 위임** | **프레임워크**에서 자주 사용 (Log4j 로거 생성, Spring Bean 생성 등) | "어떤 객체를 만들지는 자식이 결정해!" |
| **빌더**<br/>(Builder) | **단계별 조립** | **복잡한 객체 생성** (옵션 많은 여행 상품, 샌드위치 주문) | 생성자 인자가 많을 때 유용 (가독성 UP) |
| **프로토타입**<br/>(Prototype) | **복제(Clone)** | **초기화 비용이 큰 객체** (게임 몬스터 대량 생성, 그래픽 편집기 복붙) | `new` 연산자 대신 `clone()` 사용 |
| **싱글톤**<br/>(Singleton) | **유일한 인스턴스** | **공유 자원 관리** (DB 커넥션 풀, 로그 기록 객체, 환경 설정) | 전역 자원 공유 (메모리 절약) |



