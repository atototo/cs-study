---
sidebar_position: 1
---

# 🎛️ 운영체제(OS) 개요

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BrowserOnly from '@docusaurus/BrowserOnly';

> **하드웨어와 소프트웨어 사이의 중간 관리자**

---

import OSOverview from '@site/src/components/OSOverview';

## 🏗️ 컴퓨터 구조에서 OS의 위치

<OSOverview />

---

## ⚡ OS와 CPU의 관계

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const OSAndCPU = require('@site/src/components/OSAndCPU').default;
    return <OSAndCPU />;
  }}
</BrowserOnly>

---
## 🔌 부팅 과정: OS는 어떻게 시작될까?

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const BootProcess = require('@site/src/components/BootProcess').default;
    return <BootProcess />;
  }}
</BrowserOnly>

:::tip 면접 포인트: 부팅 과정

**Q: 컴퓨터 부팅 과정을 설명해주세요**

> 1. 전원이 켜지면 **CPU가 깨어나서** BIOS/UEFI 주소로 점프합니다.
> 2. **BIOS/UEFI**가 하드웨어를 점검(POST)하고 부팅 디스크를 찾습니다.
> 3. **부트로더**(GRUB, Windows Boot Manager)가 디스크에서 OS 커널을 찾아 RAM에 로드합니다.
> 4. **OS 커널**이 메모리에 올라가면 드라이버, 서비스를 초기화하고 시스템을 시작합니다.

**Q: 부트로더가 왜 필요한가요?**

> OS는 **디스크에 저장**되어 있지만, CPU는 **RAM에 있는 명령어만 실행**할 수 있습니다.
> 부트로더는 디스크의 OS를 RAM으로 복사해주는 **"중간 다리"** 역할을 합니다.

:::

---

## 🏢 비유: OS는 건물 관리인

| 건물 관리인 | OS |
|:----------:|:---:|
| 입주자(회사)에게 사무실 배정 | 프로그램에게 **메모리 할당** |
| 회의실 예약 관리 | **CPU 시간** 배분 (스케줄링) |
| 전기/수도 공급 | **하드웨어 자원** 제공 |
| 택배 수령/전달 | **파일 시스템**, I/O 관리 |
| 출입 통제 | **보안**, 권한 관리 |

---

## 🎁 OS의 핵심: 자원 추상화

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const OSAbstraction = require('@site/src/components/OSAbstraction').default;
    return <OSAbstraction />;
  }}
</BrowserOnly>

:::info 💡 추상화가 왜 중요한가?
**Spring에서 파일 저장할 때를 생각해보세요:**

```java
file.transferTo(new File("/uploads/" + filename));
```

이 한 줄 뒤에서 실제로 일어나는 일:
```
Spring → Java IO → JVM → OS System Call → 
파일시스템(ext4/NTFS) → 디바이스 드라이버 → 
디스크 컨트롤러 → 물리적 저장
```

**OS의 추상화 덕분에 우리는 이 복잡한 과정을 몰라도 됩니다!**
:::

---

## 🎯 OS의 핵심 역할 4가지

<Tabs>
  <TabItem value="process" label="1️⃣ 프로세스 관리" default>

### CPU 시간 배분 (스케줄링)

```
"누가 CPU를 쓸 차례야?"

크롬, IntelliJ, Slack이 동시에 돌아가는 것처럼 보이지만
실제로는 OS가 CPU 시간을 쪼개서 번갈아 배분
```

**관련 개념**: 프로세스, 쓰레드, 컨텍스트 스위칭, 스케줄링 알고리즘

➡️ [프로세스 vs 쓰레드](./process-thread)에서 자세히!

  </TabItem>
  <TabItem value="memory" label="2️⃣ 메모리 관리">

### 프로그램에 메모리 공간 할당

```
"프로그램아, 너 메모리 여기 써"

프로그램 실행 → OS가 가상 메모리 공간 할당
                (Code, Data, Stack, Heap)
프로그램 종료 → OS가 메모리 회수
```

**관련 개념**: 가상 메모리, 페이징, 세그멘테이션

➡️ [메모리 4영역](./memory-structure)에서 자세히!

  </TabItem>
  <TabItem value="file" label="3️⃣ 파일 시스템">

### 파일 저장/읽기/삭제 관리

```
"파일 어디 저장할까? 어디서 읽을까?"

- 파일/폴더 구조 관리
- 읽기/쓰기 권한 관리
- 디스크 공간 할당
```

**관련 개념**: 파일 디스크립터, inode, 파일 권한(rwx)

  </TabItem>
  <TabItem value="io" label="4️⃣ I/O 관리">

### 입출력 장치 관리

```
"키보드, 마우스, 모니터, 네트워크 관리"

- 하드웨어 장치들과 프로그램 사이 통신 중개
- 드라이버를 통한 하드웨어 제어
- 인터럽트 처리
```

**관련 개념**: 인터럽트, 드라이버, 버퍼

  </TabItem>
</Tabs>

---

## 💻 실무에서 만나는 OS 명령어

```bash
# 메모리 확인 (OS가 관리하는 정보)
$ free -h                    # Linux - 메모리 사용량
$ vm_stat                    # macOS

# 프로세스 확인 (OS가 관리하는 프로세스 목록)
$ ps aux                     # 전체 프로세스
$ top                        # 실시간 모니터링
$ htop                       # 더 예쁜 모니터링

# 파일 시스템 (OS가 관리)
$ ls -la                     # 파일 목록 + 권한
$ df -h                      # 디스크 사용량
$ du -sh *                   # 폴더별 용량

# 포트/네트워크 (OS가 관리)
$ netstat -an                # 네트워크 연결 상태
$ lsof -i :8080              # 8080 포트 사용 프로세스
```

---

## ☕ Java/Spring과 OS의 관계

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const JVMAndOS = require('@site/src/components/JVMAndOS').default;
    return <JVMAndOS />;
  }}
</BrowserOnly>

---

## 🎯 면접 포인트

:::tip 자주 나오는 질문

**Q: OS가 자원을 추상화한다는 게 무슨 뜻인가요?**

> OS는 복잡한 하드웨어를 **단순한 인터페이스로 감싸서** 제공합니다.
> 예를 들어 파일 저장 시, 개발자는 디스크의 섹터 위치나 컨트롤러 명령을 
> 몰라도 `write()` 한 줄로 저장할 수 있습니다.
> 이렇게 하면 **같은 코드가 SSD든 HDD든, Windows든 Linux든 동작**하고,
> 프로그램 간 자원 충돌도 OS가 관리해줍니다.

**Q: 프로그램이 실행될 때 메모리는 어떻게 할당되나요?**

> 프로그램을 실행하면 OS가 해당 **프로세스에 가상 메모리 공간**을 할당합니다.
> 이 공간은 Code, Data, Stack, Heap 4개 영역으로 나뉘고,
> OS가 각 영역의 시작 주소와 크기를 관리합니다.

**Q: CPU의 Fetch-Decode-Execute 사이클과 OS의 관계는?**

> Fetch-Decode-Execute는 **CPU 하드웨어가 자체적으로 수행**하는 동작입니다.
> OS는 이 CPU 위에서 실행되는 **소프트웨어**로, OS 코드 자체도 결국
> CPU가 Fetch-Decode-Execute로 실행하는 명령어들의 집합입니다.
> OS는 "어떤 프로그램의 명령어를 다음에 실행할지" 결정하는 역할을 합니다.

:::

:::info 이 장에서 배울 내용 미리보기

| 주제 | 핵심 질문 |
|:----:|:----------|
| [CPU 기초](./cpu-basics) | 코어, 캐시(L1/L2/L3), 파이프라이닝이란? |
| [메모리 4영역](./memory-structure) | Stack vs Heap 차이는? |
| [프로세스 vs 쓰레드](./process-thread) | 왜 멀티쓰레드를 쓰나요? |

:::

---

## 📚 참고 자료

- [GeeksforGeeks - Operating Systems](https://www.geeksforgeeks.org/operating-systems/)
- [Crash Course Computer Science #18 - Operating Systems](https://www.youtube.com/watch?v=26QPDBe-NB8)