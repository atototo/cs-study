---
sidebar_position: 1
---

# 🎛️ 운영체제(OS) 개요

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BrowserOnly from '@docusaurus/BrowserOnly';

> **하드웨어와 소프트웨어 사이의 중간 관리자**

---

import OSOverview from '@site/src/components/OSOverview';

## 🏗️ 컴퓨터 구조에서 OS의 위치

<OSOverview />

---

## ⚡ OS와 CPU의 관계

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const OSAndCPU = require('@site/src/components/OSAndCPU').default;
    return <OSAndCPU />;
  }}
</BrowserOnly>

---
## 🔌 부팅 과정: OS는 어떻게 시작될까?

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const BootProcess = require('@site/src/components/BootProcess').default;
    return <BootProcess />;
  }}
</BrowserOnly>

:::tip 면접 포인트: 부팅 과정

**Q: 컴퓨터 부팅 과정을 설명해주세요**

> 1. 전원이 켜지면 **CPU가 깨어나서** BIOS/UEFI 주소로 점프합니다.
> 2. **BIOS/UEFI**가 하드웨어를 점검(POST)하고 부팅 디스크를 찾습니다.
> 3. **부트로더**(GRUB, Windows Boot Manager)가 디스크에서 OS 커널을 찾아 RAM에 로드합니다.
> 4. **OS 커널**이 메모리에 올라가면 드라이버, 서비스를 초기화하고 시스템을 시작합니다.

**Q: 부트로더가 왜 필요한가요?**

> OS는 **디스크에 저장**되어 있지만, CPU는 **RAM에 있는 명령어만 실행**할 수 있습니다.
> 부트로더는 디스크의 OS를 RAM으로 복사해주는 **"중간 다리"** 역할을 합니다.

:::

---

## 🏢 비유: OS는 건물 관리인

| 건물 관리인 | OS |
|:----------:|:---:|
| 입주자(회사)에게 사무실 배정 | 프로그램에게 **메모리 할당** |
| 회의실 예약 관리 | **CPU 시간** 배분 (스케줄링) |
| 전기/수도 공급 | **하드웨어 자원** 제공 |
| 택배 수령/전달 | **파일 시스템**, I/O 관리 |
| 출입 통제 | **보안**, 권한 관리 |

---

## 🎁 OS의 핵심: 자원 추상화

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const OSAbstraction = require('@site/src/components/OSAbstraction').default;
    return <OSAbstraction />;
  }}
</BrowserOnly>

:::info 💡 추상화가 왜 중요한가?
**Spring에서 파일 저장할 때를 생각해보세요:**

```java
file.transferTo(new File("/uploads/" + filename));
```

이 한 줄 뒤에서 실제로 일어나는 일:
```
Spring → Java IO → JVM → OS System Call → 
파일시스템(ext4/NTFS) → 디바이스 드라이버 → 
디스크 컨트롤러 → 물리적 저장
```

**OS의 추상화 덕분에 우리는 이 복잡한 과정을 몰라도 됩니다!**
:::

---

## 🎯 OS의 핵심 역할 4가지

<Tabs>
  <TabItem value="process" label="1️⃣ 프로세스 관리" default>

### CPU 시간 배분 (스케줄링)

```
"누가 CPU를 쓸 차례야?"

크롬, IntelliJ, Slack이 동시에 돌아가는 것처럼 보이지만
실제로는 OS가 CPU 시간을 쪼개서 번갈아 배분
```

**관련 개념**: 프로세스, 쓰레드, 컨텍스트 스위칭, 스케줄링 알고리즘

➡️ [프로세스 vs 쓰레드](./process-thread)에서 자세히!

  </TabItem>
  <TabItem value="memory" label="2️⃣ 메모리 관리">

### 프로그램에 메모리 공간 할당

```
"프로그램아, 너 메모리 여기 써"

프로그램 실행 → OS가 가상 메모리 공간 할당
                (Code, Data, Stack, Heap)
프로그램 종료 → OS가 메모리 회수
```

**관련 개념**: 가상 메모리, 페이징, 세그멘테이션

➡️ [메모리 4영역](./memory-structure)에서 자세히!

  </TabItem>
  <TabItem value="file" label="3️⃣ 파일 시스템">

### 파일 저장/읽기/삭제 관리

```
"파일 어디 저장할까? 어디서 읽을까?"

- 파일/폴더 구조 관리
- 읽기/쓰기 권한 관리
- 디스크 공간 할당
```

**관련 개념**: 파일 디스크립터, inode, 파일 권한(rwx)

  </TabItem>
  <TabItem value="io" label="4️⃣ I/O 관리">

### 입출력 장치 관리

```
"키보드, 마우스, 모니터, 네트워크 관리"

- 하드웨어 장치들과 프로그램 사이 통신 중개
- 드라이버를 통한 하드웨어 제어
- 인터럽트 처리
```

**관련 개념**: 인터럽트, 드라이버, 버퍼

  </TabItem>
</Tabs>

---

## 🔐 커널 모드 vs 유저 모드

CPU는 **보안과 안정성**을 위해 두 가지 실행 모드를 가집니다.

<BrowserOnly>
  {() => {
    const KernelUserMode = require('@site/src/components/KernelUserMode').default;
    return <KernelUserMode />;
  }}
</BrowserOnly>

### 왜 모드를 분리할까?

악성 프로그램이 하드웨어를 직접 조작하거나, 다른 프로세스의 메모리를 훔쳐보는 것을 방지합니다.

:::tip 면접 포인트
**Q: Spring Boot 애플리케이션은 어느 모드에서 실행되나요?**

A: **유저 모드**에서 실행됩니다. 파일 저장, 네트워크 통신 등이 필요할 때만 시스템 콜을 통해 잠시 커널 모드로 전환됩니다.
:::

---

## 🔗 시스템 콜 (System Call)

**시스템 콜**은 유저 모드 프로그램이 커널에게 작업을 요청하는 **공식 창구**입니다.

<BrowserOnly>
  {() => {
    const SystemCallDiagram = require('@site/src/components/SystemCallDiagram').default;
    return <SystemCallDiagram />;
  }}
</BrowserOnly>

### 주요 시스템 콜 분류

| 분류 | 시스템 콜 예시 | Java/Spring 대응 |
|------|---------------|-----------------|
| **프로세스** | `fork()`, `exec()`, `exit()` | `Runtime.exec()`, `ProcessBuilder` |
| **파일** | `open()`, `read()`, `write()`, `close()` | `FileInputStream`, `Files.write()` |
| **메모리** | `mmap()`, `brk()` | `new` 연산자 (JVM이 내부 처리) |
| **네트워크** | `socket()`, `bind()`, `connect()` | `Socket`, `ServerSocket` |

:::caution 시스템 콜은 비싸다
모드 전환(User → Kernel → User)에는 **컨텍스트 저장/복원** 비용이 듭니다.

그래서 Java의 `BufferedOutputStream`은 데이터를 모아서 한 번에 `write()` 시스템 콜을 호출합니다.
:::

---

## ⚡ Mode Switch vs Context Switch

시스템 콜이 비싼 이유를 이해하려면 두 가지 개념을 구분해야 합니다.

### 🔄 Mode Switch (모드 스위치)

**권한 레벨만 바뀌는 것**입니다.

```
User Mode (Ring 3) ←→ Kernel Mode (Ring 0)
```

- **언제 발생?** 시스템 콜 할 때마다 **항상** 발생
- **뭐가 바뀜?** CPU의 권한 레벨만 변경
- **비용:** 상대적으로 가벼움
  - 일부 레지스터 저장
  - 권한 체크
  - 시스템 콜 테이블 조회

:::note 비유
회사에서 **보안 구역 출입**하는 것과 같아요.  
출입증 찍고 들어가면 끝 - 내 자리와 작업 내용은 그대로입니다.
:::

### 🔀 Context Switch (컨텍스트 스위치)

**실행 중인 프로세스/쓰레드 자체가 바뀌는 것**입니다.

```
프로세스 A 실행 중 → 프로세스 B로 교체
```

- **언제 발생?** 
  - I/O 대기로 블로킹될 때
  - 타임슬라이스(할당 시간) 만료
  - 더 높은 우선순위 프로세스 등장
- **뭐가 바뀜?** 실행 주체 전체!
- **비용:** 무거움 💥

#### Context Switch 시 저장/복원해야 하는 것들

| 항목 | 설명 |
|-----|------|
| **PC (Program Counter)** | 어디까지 실행했는지 |
| **레지스터 값들** | CPU 계산 중간 결과 전부 |
| **Stack Pointer** | 스택 어디까지 썼는지 |
| **MMU 매핑 정보** | 가상 → 물리 주소 변환 테이블 |
| **CPU 캐시** | **무효화됨!** 💥 |

:::caution CPU 캐시 무효화가 치명적인 이유
- L1/L2/L3 캐시에 있던 데이터가 새 프로세스와 무관해짐
- 다시 메모리에서 가져와야 함 → **Cache Miss 폭증**
- 이게 Context Switch가 진짜 비싼 이유입니다
:::

:::note 비유
회사에서 **자리를 완전히 바꾸는 것**과 같아요.  
모니터에 띄워둔 문서, 메모장, 계산기 결과... 다 치우고 새로 세팅해야 합니다.
:::

---

### 📍 시스템 콜 시 실제로 일어나는 일

`read()` 시스템 콜 하나를 호출하면:

```
1. read() 시스템 콜 호출
      ↓
2. Mode Switch (User → Kernel)     ← 항상 발생
      ↓
3. 디스크 I/O 요청
      ↓
4. I/O 완료 대기... 🕐
   └─ 여기서 Context Switch 발생!
      (다른 프로세스한테 CPU 양보)
      ↓
5. I/O 완료 → 다시 내 차례
   └─ 또 Context Switch!
      (내 컨텍스트 복원, 캐시 다시 채움)
      ↓
6. Mode Switch (Kernel → User)     ← 항상 발생
      ↓
7. 데이터 반환
```

:::tip 핵심 정리
- **Mode Switch**: 시스템 콜마다 **최소 2번** (들어갈 때 + 나올 때)
- **Context Switch**: I/O 블로킹 시 **추가로** 발생할 수 있음
- 그래서 시스템 콜 횟수를 줄이는 게 중요!
:::

---

### 💡 BufferedReader가 빠른 이유

이제 왜 `BufferedReader`가 빠른지 이해할 수 있습니다.

#### ❌ 비효율적인 방식: 1바이트마다 시스템 콜

```java
// 100바이트 읽으면 → 100번 시스템 콜!
while ((b = inputStream.read()) != -1) {
    // 매번 read() 시스템 콜 발생
}
```

**100바이트 읽을 때:**
- 시스템 콜: **100번**
- Mode Switch: **200번**
- Context Switch: 다수 발생 가능 💥

#### ✅ 효율적인 방식: 8KB씩 한 번에

```java
// 100바이트 읽어도 → 1번 시스템 콜!
BufferedInputStream bis = new BufferedInputStream(inputStream);
while ((b = bis.read()) != -1) {
    // 대부분 User Space 버퍼에서 읽음
}
```

**100바이트 읽을 때:**
- 시스템 콜: **1번** (8KB 버퍼 채우기)
- Mode Switch: **2번**
- Context Switch: 최소화 ✨

#### 동작 원리

<BrowserOnly>
  {() => {
    const BufferedIODiagram = require('@site/src/components/BufferedIODiagram').default;
    return <BufferedIODiagram />;
  }}
</BrowserOnly>

**핵심:** User Space의 버퍼에서 읽는 동안은 커널 개입 없이 진행됩니다.

---

### 🎯 면접 포인트

:::tip Q: 시스템 콜이 비싼 이유가 뭔가요?

**모범 답변:**

> 시스템 콜이 비싼 이유는 크게 두 가지입니다.
>
> 첫째, **Mode Switch** 비용입니다. 매번 User Mode에서 Kernel Mode로 전환할 때 권한 체크와 일부 레지스터 저장이 필요합니다.
>
> 둘째, **Context Switch** 가능성입니다. I/O 작업처럼 블로킹이 발생하면 다른 프로세스로 전환되는데, 이때 모든 레지스터를 저장/복원하고 CPU 캐시가 무효화됩니다. 캐시 무효화로 인한 Cache Miss가 가장 큰 성능 저하 요인입니다.
>
> 그래서 `BufferedReader`처럼 시스템 콜 횟수를 줄이는 버퍼링이 성능에 중요합니다.
:::

:::tip Q: Mode Switch와 Context Switch의 차이점은?

**모범 답변:**

> **Mode Switch**는 권한 레벨만 바뀌는 것입니다. User Mode와 Kernel Mode 간 전환으로, 시스템 콜할 때 항상 발생합니다. 비용은 상대적으로 가볍습니다.
>
> **Context Switch**는 실행 주체 자체가 바뀌는 것입니다. 프로세스나 쓰레드 전환 시 발생하며, 모든 레지스터 저장/복원과 CPU 캐시 무효화 때문에 훨씬 무겁습니다.
>
> 시스템 콜 한 번에 Mode Switch는 필수지만, Context Switch는 I/O 블로킹 같은 상황에서 추가로 발생할 수 있습니다.
:::

---

{/* 시각화 컴포넌트 */}
<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const ModeSwitchVsContextSwitch = require('@site/src/components/ModeSwitchVsContextSwitch').default;
    return <ModeSwitchVsContextSwitch />;
  }}
</BrowserOnly>

---

## ⚡ 인터럽트 (Interrupt)

**인터럽트**는 CPU에게 "지금 하던 일 멈추고 이것 좀 처리해!"라고 알리는 신호입니다.

<BrowserOnly>
  {() => {
    const InterruptDiagram = require('@site/src/components/InterruptDiagram').default;
    return <InterruptDiagram />;
  }}
</BrowserOnly>

### 인터럽트가 없다면?

CPU가 키보드 입력을 받으려면 "입력 있어?" "없네" "입력 있어?" "없네"... 
이렇게 **폴링(Polling)**을 해야 합니다. 엄청난 자원 낭비죠!

인터럽트 덕분에 CPU는 다른 일을 하다가, 키보드가 "입력 왔어!"라고 알려줄 때만 처리하면 됩니다.

:::tip 면접 포인트
**Q: 타이머 인터럽트가 왜 중요한가요?**

A: **선점형 스케줄링**의 핵심입니다. 타이머 인터럽트가 주기적으로 발생해야 OS가 "이 프로세스 너무 오래 실행됐네, 다음 프로세스 차례!"라고 판단할 수 있습니다.
:::

### 실제로 확인해보기

```bash
# Linux에서 인터럽트 발생 횟수 확인
cat /proc/interrupts
```

---

## 💻 실무에서 만나는 OS 명령어

```bash
# 메모리 확인 (OS가 관리하는 정보)
$ free -h                    # Linux - 메모리 사용량
$ vm_stat                    # macOS

# 프로세스 확인 (OS가 관리하는 프로세스 목록)
$ ps aux                     # 전체 프로세스
$ top                        # 실시간 모니터링
$ htop                       # 더 예쁜 모니터링

# 파일 시스템 (OS가 관리)
$ ls -la                     # 파일 목록 + 권한
$ df -h                      # 디스크 사용량
$ du -sh *                   # 폴더별 용량

# 포트/네트워크 (OS가 관리)
$ netstat -an                # 네트워크 연결 상태
$ lsof -i :8080              # 8080 포트 사용 프로세스
```

---

## ☕ Java/Spring과 OS의 관계

<BrowserOnly fallback={<div style={{padding: '40px', textAlign: 'center', color: '#94a3b8'}}>로딩 중...</div>}>
  {() => {
    const JVMAndOS = require('@site/src/components/JVMAndOS').default;
    return <JVMAndOS />;
  }}
</BrowserOnly>

---

## 🎯 면접 포인트

:::tip 자주 나오는 질문

**Q: OS가 자원을 추상화한다는 게 무슨 뜻인가요?**

> OS는 복잡한 하드웨어를 **단순한 인터페이스로 감싸서** 제공합니다.
> 예를 들어 파일 저장 시, 개발자는 디스크의 섹터 위치나 컨트롤러 명령을 
> 몰라도 `write()` 한 줄로 저장할 수 있습니다.
> 이렇게 하면 **같은 코드가 SSD든 HDD든, Windows든 Linux든 동작**하고,
> 프로그램 간 자원 충돌도 OS가 관리해줍니다.

**Q: 프로그램이 실행될 때 메모리는 어떻게 할당되나요?**

> 프로그램을 실행하면 OS가 해당 **프로세스에 가상 메모리 공간**을 할당합니다.
> 이 공간은 Code, Data, Stack, Heap 4개 영역으로 나뉘고,
> OS가 각 영역의 시작 주소와 크기를 관리합니다.

**Q: CPU의 Fetch-Decode-Execute 사이클과 OS의 관계는?**

> Fetch-Decode-Execute는 **CPU 하드웨어가 자체적으로 수행**하는 동작입니다.
> OS는 이 CPU 위에서 실행되는 **소프트웨어**로, OS 코드 자체도 결국
> CPU가 Fetch-Decode-Execute로 실행하는 명령어들의 집합입니다.
> OS는 "어떤 프로그램의 명령어를 다음에 실행할지" 결정하는 역할을 합니다.

:::

:::info 이 장에서 배울 내용 미리보기

| 주제 | 핵심 질문 |
|:----:|:----------|
| [CPU 기초](./cpu-basics) | 코어, 캐시(L1/L2/L3), 파이프라이닝이란? |
| [메모리 4영역](./memory-structure) | Stack vs Heap 차이는? |
| [프로세스 vs 쓰레드](./process-thread) | 왜 멀티쓰레드를 쓰나요? |

:::

---

## 📚 참고 자료

- [GeeksforGeeks - Operating Systems](https://www.geeksforgeeks.org/operating-systems/)
- [Crash Course Computer Science #18 - Operating Systems](https://www.youtube.com/watch?v=26QPDBe-NB8)