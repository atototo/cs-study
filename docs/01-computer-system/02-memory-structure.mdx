---
sidebar_position: 2
---

import MemoryStructure from '@site/src/components/MemoryStructure';

# 🧱 메모리 4영역

> 프로그램이 실행되면 OS가 메모리 공간을 할당해줘요. 이 공간이 **4개 영역**으로 나뉩니다.

---

## 🎮 인터랙티브 시각화

아래에서 각 영역을 클릭해보고, Stack 애니메이션도 확인해보세요!

<MemoryStructure />

---

## 📐 메모리 구조 개요

```
┌─────────────────┐  ← 높은 주소
│      Stack      │  지역변수, 함수 호출
├─────────────────┤
│        ↓        │
│                 │  (빈 공간)
│        ↑        │
├─────────────────┤
│      Heap       │  동적 할당 (new, malloc)
├─────────────────┤
│      Data       │  전역변수, static 변수
├─────────────────┤
│      Code       │  실행할 코드 자체
└─────────────────┘  ← 낮은 주소
```

---

## 🏢 비유: 회사 사무실

| 영역 | 비유 | 특징 |
|------|------|------|
| **Code** | 업무 매뉴얼 | 읽기 전용, 바뀌지 않음 |
| **Data** | 공용 게시판 | 모든 직원이 공유, 프로그램 시작~끝까지 유지 |
| **Heap** | 공용 창고 | 필요할 때 빌려쓰고, 다 쓰면 반납 |
| **Stack** | 각자 책상 | 내 일만 처리, 일 끝나면 정리 |

---

## 📝 각 영역 상세

### 1. Code 영역 (Text)

```java
public int add(int a, int b) {
    return a + b;  // ← 이 코드 자체가 Code 영역에 저장
}
```

- **뭐가 저장?** 작성한 코드(기계어로 변환된)
- **특징:** 읽기 전용 (실행 중 변경 불가)

---

### 2. Data 영역

```java
public class Example {
    static int count = 0;     // ← Data 영역 (static)
    static String name = "A"; // ← Data 영역
}
```

- **뭐가 저장?** 전역변수, static 변수
- **특징:** 프로그램 시작할 때 할당, 끝날 때 해제

:::tip 실무 연결
`static` 변수가 왜 모든 인스턴스에서 공유되는지 이해됨!
:::

---

### 3. Stack 영역 ⭐

```java
public void calculate() {
    int x = 10;        // ← Stack에 x 생성
    int y = 20;        // ← Stack에 y 생성
    int result = add(x, y);
}

public int add(int a, int b) {
    int sum = a + b;   // ← 새 Stack 프레임에 a, b, sum 생성
    return sum;        // ← 함수 끝나면 이 프레임 삭제됨
}
```

- **뭐가 저장?** 지역변수, 함수 매개변수, 리턴 주소
- **특징:** 
  - 함수 호출 → 쌓임 (Push)
  - 함수 종료 → 제거 (Pop)
  - **LIFO** (Last In First Out)
- **크기:** 고정 (보통 1~8MB)

---

### 4. Heap 영역 ⭐

```java
public void createUser() {
    User user = new User("영은");
    //   ↑ user 변수는 Stack에 (주소만 저장)
    //         ↑ 실제 User 객체는 Heap에
}
```

- **뭐가 저장?** `new`로 생성한 객체, 배열
- **특징:**
  - 개발자가 직접 관리 (할당/해제)
  - Java는 GC가 자동 해제
  - **크기 유동적** (런타임에 결정)

:::danger 실무에서 자주 보는 에러
```
java.lang.OutOfMemoryError: Java heap space
```
→ Heap이 꽉 참 = 객체를 너무 많이 만들거나, GC가 못 지움
:::

---

## ⚔️ Stack vs Heap 비교 (면접 필수!)

| 구분 | Stack | Heap |
|------|-------|------|
| **저장 대상** | 지역변수, 매개변수 | 객체, 배열 |
| **할당 속도** | 빠름 ⚡ | 느림 |
| **크기** | 고정 (작음) | 유동적 (큼) |
| **관리** | 자동 (함수 끝나면 삭제) | 수동 or GC |
| **에러** | StackOverflowError | OutOfMemoryError |
| **접근** | 지역적 (해당 함수만) | 전역적 (참조 있으면 어디서든) |

---

## 💻 코드로 전체 정리

```java
public class MemoryExample {
    // [Data 영역] - static 변수
    static int staticVar = 100;
    
    public static void main(String[] args) {
        // [Stack 영역] - 지역변수
        int localVar = 10;
        
        // [Heap 영역] - new로 생성된 객체
        // user 변수(참조)는 Stack에, 실제 객체는 Heap에
        User user = new User("영은");
        
        // [Code 영역] - 이 코드 자체
    }
}
```

---

## 🎯 면접 예상 질문

### Q1: Stack과 Heap의 차이점을 설명해주세요

> **A:** Stack은 지역변수와 함수 호출 정보를 저장하며, 함수가 끝나면 자동으로 해제됩니다. 크기가 고정되어 있고 접근 속도가 빠릅니다.
> Heap은 new로 생성한 객체를 저장하며, 개발자가 직접 관리하거나 GC가 해제합니다. 크기가 유동적이고 어디서든 참조로 접근 가능합니다.

### Q2: 재귀 함수를 너무 많이 호출하면 왜 StackOverflowError가 날까요?

> **A:** 함수가 호출될 때마다 Stack에 프레임이 쌓이는데, 재귀가 너무 깊어지면 Stack 영역의 한계(보통 1~8MB)를 초과하기 때문입니다.

---

## ✅ 체크리스트

- [ ] 메모리 4영역(Code, Data, Stack, Heap) 구분 가능
- [ ] Stack과 Heap의 차이 설명 가능
- [ ] StackOverflowError와 OutOfMemoryError 원인 설명 가능
- [ ] 다음 단계: [프로세스 vs 쓰레드](/docs/01-computer-system/03-process-thread) 학습
